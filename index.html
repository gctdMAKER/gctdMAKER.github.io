<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grilled Cheese Tower Defense - The Website!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chewy&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FDF4E3; /* Creamy background */
        }
        .font-chewy {
            font-family: 'Chewy', cursive;
        }
        #game-section canvas {
            cursor: not-allowed;
            background-color: #2E8B57; /* SeaGreen fallback */
        }
        .tower-select-button.selected {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
            border-color: #FBBF24;
        }
        .game-over-modal, .boss-alert, .demon-mode-alert, #game-index-modal, #hell-mode-alert, #mode-select-modal, #reset-save-modal, #vote-modal, .custom-game-modal {
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        #enemy-index-content::-webkit-scrollbar, #tower-index-content::-webkit-scrollbar, #admin-panel div::-webkit-scrollbar, .custom-select-content::-webkit-scrollbar {
            width: 8px;
        }
        #enemy-index-content::-webkit-scrollbar-track, #tower-index-content::-webkit-scrollbar-track, #admin-panel div::-webkit-scrollbar-track, .custom-select-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        #enemy-index-content::-webkit-scrollbar-thumb, #tower-index-content::-webkit-scrollbar-thumb, #admin-panel div::-webkit-scrollbar-thumb, .custom-select-content::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        #enemy-index-content::-webkit-scrollbar-thumb:hover, #tower-index-content::-webkit-scrollbar-thumb:hover, #admin-panel div::-webkit-scrollbar-thumb:hover, .custom-select-content::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .hero-bg {
            background-image: linear-gradient(rgba(253, 244, 227, 0.8), rgba(253, 244, 227, 1)), url('https://placehold.co/1200x800/2E8B57/FFFFFF?text=Gooey+Battlefield');
            background-size: cover;
            background-position: center;
        }
        .tab-button.active {
            border-bottom-color: #FBBF24;
            color: #c2410c;
        }
        .speed-button.active {
            background-color: #3b82f6;
            transform: scale(1.05);
        }
        .mode-button {
            transition: all 0.2s ease-in-out;
        }
        .mode-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="bg-yellow-50">

    <!-- Header -->
    <header class="bg-amber-500 shadow-md sticky top-0 z-50">
        <nav class="container mx-auto px-6 py-3 flex justify-between items-center">
            <div class="font-chewy text-2xl text-white" style="text-shadow: 1px 1px #a16207;">Version 32</div>
            <div>
                <a href="#how-to-play" class="text-white hover:text-amber-200 mx-3 font-semibold">How to Play</a>
                <a href="#game-section" id="play-now-button" class="bg-white text-amber-600 font-bold py-2 px-4 rounded-lg hover:bg-amber-100 transition-colors">Play Now</a>
            </div>
        </nav>
    </header>

    <!-- Hero Section -->
    <section class="hero-bg py-20 md:py-32">
        <div class="container mx-auto text-center px-6">
            <h1 class="text-6xl md:text-8xl font-chewy text-amber-700" style="text-shadow: 2px 2px #fff, 4px 4px #FBBF24;">Grilled Cheese Tower Defense</h1>
            <p class="text-xl md:text-2xl text-amber-800 mt-4 max-w-3xl mx-auto font-semibold">The ultimate battle of bread and butter! Defend your delicious base from hordes of hungry, marauding crumbs. Strategize, build, and melt your way to victory!</p>
            <a href="#game-section" id="start-game-button" class="mt-8 inline-block bg-amber-500 text-white font-bold text-2xl py-4 px-10 rounded-xl shadow-lg hover:bg-amber-600 transition-transform transform hover:scale-105">Start Defending!</a>
        </div>
    </section>

    <!-- How to Play Section -->
    <section id="how-to-play" class="py-16 bg-white">
        <div class="container mx-auto px-6">
            <h2 class="text-5xl font-chewy text-amber-600 mb-12 text-center">How to Play</h2>
            <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-8">
                <div class="bg-amber-50 p-6 rounded-lg shadow-md border-2 border-amber-200">
                    <h3 class="text-2xl font-bold text-amber-800 mb-2">1. Earn Gold</h3>
                    <p class="text-gray-600">Your primary resource is Gold, earned by defeating enemies. Each crumb you vanquish adds to your treasury, allowing you to build a formidable cheesy fortress.</p>
                </div>
                <div class="bg-amber-50 p-6 rounded-lg shadow-md border-2 border-amber-200">
                    <h3 class="text-2xl font-bold text-amber-800 mb-2">2. Build Towers</h3>
                    <p class="text-gray-600">Use your gold to build a variety of cheese-themed towers from the menu. Each tower has unique strengths. Place them strategically along the path to create deadly kill zones.</p>
                </div>
                <div class="bg-amber-50 p-6 rounded-lg shadow-md border-2 border-amber-200">
                    <h3 class="text-2xl font-bold text-amber-800 mb-2">3. Upgrade and Sell</h3>
                    <p class="text-gray-600">Click on a placed tower to open its upgrade menu. Spend gold to increase its power, or sell it (for half its total cost) to make room for a different strategy.</p>
                </div>
                <div class="bg-amber-50 p-6 rounded-lg shadow-md border-2 border-amber-200">
                    <h3 class="text-2xl font-bold text-amber-800 mb-2">4. Know Your Enemy</h3>
                    <p class="text-gray-600">Use the in-game 'Game Index' to learn about the different enemy types. Knowing their health, speed, and special abilities is key to choosing the right towers for the job.</p>
                </div>
                 <div class="bg-amber-50 p-6 rounded-lg shadow-md border-2 border-amber-200">
                    <h3 class="text-2xl font-bold text-amber-800 mb-2">5. Survive the Waves</h3>
                    <p class="text-gray-600">Enemies come in waves, with each wave getting progressively harder. Prepare for stronger foes, tricky new enemy types, and devastating bosses that appear every 10 waves.</p>
                </div>
                <div class="bg-amber-50 p-6 rounded-lg shadow-md border-2 border-amber-200">
                    <h3 class="text-2xl font-bold text-amber-800 mb-2">6. Protect Your Base</h3>
                    <p class="text-gray-600">The ultimate goal is to prevent enemies from reaching your Grilled Cheese base at the end of the path. If your base's health drops to zero, the game is over!</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Game Section -->
    <section id="game-section" class="py-16">
        <div class="w-full max-w-5xl mx-auto px-4">
            <!-- Game Info Panel -->
            <div class="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-4 text-center">
                <div class="bg-white p-3 rounded-lg shadow-md border-2 border-amber-300">
                    <p class="text-sm text-gray-500 font-semibold">GOLD</p>
                    <p id="gold-display" class="text-2xl font-bold text-amber-500">100</p>
                </div>
                <div class="bg-white p-3 rounded-lg shadow-md border-2 border-amber-300">
                    <p class="text-sm text-gray-500 font-semibold">BASE HEALTH</p>
                    <p id="lives-display" class="text-2xl font-bold text-red-500">1500</p>
                </div>
                <div class="bg-white p-3 rounded-lg shadow-md border-2 border-amber-300">
                    <p class="text-sm text-gray-500 font-semibold">WAVE</p>
                    <p id="wave-display" class="text-2xl font-bold text-sky-500">0</p>
                </div>
                 <div class="bg-white p-3 rounded-lg shadow-md border-2 border-amber-300">
                    <p class="text-sm text-gray-500 font-semibold">NEXT WAVE IN</p>
                    <p id="timer-display" class="text-2xl font-bold text-gray-600">--</p>
                </div>
            </div>

            <!-- Game Canvas -->
            <div class="relative w-full aspect-[16/10] shadow-lg rounded-xl overflow-hidden border-4 border-amber-400">
                <div id="pre-game-overlay" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center text-white p-8 text-center z-30">
                    <h2 class="text-4xl font-chewy text-amber-400 mb-4">Ready to Defend?</h2>
                    <p class="text-lg">Click "Start Defending!" above to begin the cheesy onslaught!</p>
                </div>
                <canvas id="gameCanvas"></canvas>

                <!-- Mode Select Modal -->
                <div id="mode-select-modal" class="absolute inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center text-white p-8 text-center hidden z-40">
                    <h2 class="text-6xl font-chewy text-amber-400 mb-8">Select a Mode</h2>
                    <div id="mode-select-container" class="flex flex-col items-center gap-8">
                        <button id="continue-button" class="mode-button bg-sky-600 border-4 border-sky-400 p-6 rounded-xl w-64 hidden">
                            <h3 class="text-3xl font-chewy">Continue Game</h3>
                            <p id="continue-info" class="mt-2"></p>
                        </button>
                        <div class="flex flex-col md:flex-row gap-8">
                            <button id="normal-mode-button" class="mode-button bg-green-600 border-4 border-green-400 p-6 rounded-xl w-64">
                                <h3 class="text-3xl font-chewy">Normal Mode</h3>
                                <p class="mt-2">The standard cheesy challenge.</p>
                            </button>
                            <button id="hard-mode-button" class="mode-button bg-orange-600 border-4 border-orange-400 p-6 rounded-xl w-64">
                                <h3 class="text-3xl font-chewy">Hard Mode</h3>
                                <p class="mt-2">Enemies have 1.5x health and are 1.2x faster.</p>
                            </button>
                            <button id="hardcore-mode-button" class="mode-button bg-red-700 border-4 border-red-500 p-6 rounded-xl w-64">
                                <h3 class="text-3xl font-chewy">Hardcore Mode</h3>
                                <p class="mt-2">Start with 550 Gold & 10000 Base Health. Waves progress slower, but enemies are much tougher!</p>
                            </button>
                        </div>
                        <button id="custom-mode-button" class="mode-button bg-purple-600 border-4 border-purple-400 p-6 rounded-xl w-64">
                            <h3 class="text-3xl font-chewy">Custom Mode</h3>
                            <p class="mt-2">Create your own challenge!</p>
                        </button>
                    </div>
                </div>

                 <!-- Custom Game Modals -->
                <div id="custom-tower-select-modal" class="custom-game-modal absolute inset-0 bg-black bg-opacity-90 flex flex-col items-center justify-center p-4 text-white hidden z-45">
                    <div class="bg-amber-100 text-black w-full max-w-4xl h-full max-h-[90vh] rounded-xl shadow-lg flex flex-col p-4">
                        <h2 class="text-3xl font-chewy text-amber-700 mb-4">Custom Game: Select Your Towers</h2>
                        <div class="custom-select-content flex-grow overflow-y-auto pr-2 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            <!-- JS will populate this -->
                        </div>
                        <div class="mt-4 flex justify-end gap-4">
                             <button id="custom-towers-next-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg">Next</button>
                        </div>
                    </div>
                </div>
                 <div id="custom-enemy-select-modal" class="custom-game-modal absolute inset-0 bg-black bg-opacity-90 flex flex-col items-center justify-center p-4 text-white hidden z-45">
                     <div class="bg-amber-100 text-black w-full max-w-4xl h-full max-h-[90vh] rounded-xl shadow-lg flex flex-col p-4">
                        <h2 class="text-3xl font-chewy text-amber-700 mb-4">Custom Game: Select Your Enemies</h2>
                        <div class="custom-select-content flex-grow overflow-y-auto pr-2 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            <!-- JS will populate this -->
                        </div>
                        <div class="mt-4 flex justify-between gap-4">
                             <button id="custom-enemies-back-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg">Back</button>
                             <button id="custom-enemies-next-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg">Next</button>
                        </div>
                    </div>
                </div>
                 <div id="custom-difficulty-select-modal" class="custom-game-modal absolute inset-0 bg-black bg-opacity-90 flex items-center justify-center p-4 text-white hidden z-45">
                     <div class="bg-amber-100 text-black w-full max-w-lg rounded-xl shadow-lg flex flex-col p-8 items-center">
                        <h2 class="text-3xl font-chewy text-amber-700 mb-6">Custom Game: Select Difficulty</h2>
                        <div class="flex gap-4 mb-6">
                            <button class="difficulty-button mode-button bg-green-500 p-4 rounded-lg" data-difficulty="0.75">Easy</button>
                            <button class="difficulty-button mode-button bg-yellow-500 p-4 rounded-lg" data-difficulty="1">Medium</button>
                            <button class="difficulty-button mode-button bg-red-500 p-4 rounded-lg" data-difficulty="1.5">Hard</button>
                        </div>
                        <div class="mt-4 flex justify-between w-full gap-4">
                             <button id="custom-difficulty-back-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg">Back</button>
                             <button id="custom-start-game-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg">Start Game</button>
                        </div>
                    </div>
                </div>
                
                <!-- Game Over Modal -->
                <div id="game-over-modal" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center text-white p-8 text-center hidden opacity-0 scale-90 z-30">
                    <h2 id="game-over-title" class="text-6xl font-chewy text-amber-400 mb-4">Game Over</h2>
                    <p id="game-over-message" class="text-xl mb-6">The hungry hordes have overwhelmed you!</p>
                    <button id="restart-button" class="bg-amber-500 hover:bg-amber-600 text-white font-bold py-3 px-6 rounded-lg text-xl shadow-lg transition-transform transform hover:scale-105">
                        Play Again
                    </button>
                </div>

                 <!-- Reset Save Confirmation Modal -->
                <div id="reset-save-modal" class="absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center text-white p-8 text-center hidden opacity-0 scale-90 z-40">
                    <div class="text-center">
                        <h2 class="text-4xl font-chewy text-amber-400 mb-4">Reset Save File?</h2>
                        <p class="text-lg mb-6">Are you sure? This will permanently delete your saved progress.<br>This action cannot be undone.</p>
                        <div class="flex gap-4 justify-center">
                            <button id="confirm-reset-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg text-xl shadow-lg">Yes, Delete</button>
                            <button id="cancel-reset-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg text-xl shadow-lg">Cancel</button>
                        </div>
                    </div>
                </div>

                 <!-- Vote Modal -->
                <div id="vote-modal" class="absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center text-white p-8 text-center hidden z-40">
                     <div class="bg-amber-100 text-black w-full max-w-lg rounded-xl shadow-lg flex flex-col p-8 items-center">
                        <h2 class="text-3xl font-chewy text-amber-700 mb-4">Community Poll</h2>
                        <p class="text-lg text-gray-800 mb-6">Should I add a feature where enemies can destroy towers?</p>
                        <div class="flex gap-4 mb-4">
                            <button id="vote-yes-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-xl shadow-lg">Yes</button>
                            <button id="vote-no-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg text-xl shadow-lg">No</button>
                        </div>
                        <div class="w-full bg-gray-300 rounded-full h-6 overflow-hidden">
                            <div id="vote-bar-yes" class="bg-green-500 h-full" style="width: 50%;"></div>
                        </div>
                        <div class="w-full flex justify-between mt-1 text-sm font-bold">
                            <span id="vote-count-yes">0</span>
                            <span id="vote-count-no">0</span>
                        </div>
                        <button id="close-vote-button" class="mt-6 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">Close</button>
                    </div>
                </div>
                
                <!-- Alerts -->
                <div id="boss-alert" class="absolute inset-0 flex items-center justify-center hidden opacity-0 z-10 pointer-events-none">
                     <h2 class="text-8xl font-chewy text-red-600" style="text-shadow: 4px 4px #000;">BOSS LEVEL</h2>
                </div>
                <div id="demon-mode-alert" class="absolute inset-0 flex items-center justify-center hidden opacity-0 z-20 pointer-events-none">
                     <h2 class="text-8xl font-chewy text-purple-800" style="text-shadow: 4px 4px #000;">DEMON MODE</h2>
                </div>
                <div id="hell-mode-alert" class="absolute inset-0 flex items-center justify-center hidden opacity-0 z-20 pointer-events-none">
                     <h2 class="text-8xl font-chewy text-red-800" style="text-shadow: 4px 4px #000;">HELL MODE</h2>
                </div>
                <div id="pause-overlay" class="absolute inset-0 bg-black bg-opacity-50 flex flex-col items-center justify-center text-white p-8 text-center hidden z-35">
                    <h2 class="text-6xl font-chewy text-amber-400">Game Paused</h2>
                </div>
                <div id="speed-indicator" class="absolute top-4 right-4 text-white font-bold text-2xl font-chewy hidden z-10" style="text-shadow: 2px 2px #000;">
                    2x Speed
                </div>

                <!-- Game Index Modal -->
                <div id="game-index-modal" class="absolute inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center text-white p-4 md:p-8 text-center hidden opacity-0 scale-90 z-40">
                    <div class="bg-amber-100 text-black w-full max-w-4xl h-full max-h-[80vh] rounded-xl shadow-lg flex flex-col p-4">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-3xl font-chewy text-amber-700">Game Index</h2>
                            <button id="close-index-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-full text-xl">&times;</button>
                        </div>
                        <div class="flex border-b border-amber-300 mb-2">
                            <button id="show-towers-tab" class="tab-button py-2 px-4 font-semibold border-b-4 border-transparent">Towers</button>
                            <button id="show-enemies-tab" class="tab-button py-2 px-4 font-semibold border-b-4 border-transparent active">Enemies</button>
                        </div>
                        <div id="tower-index-content" class="flex-grow overflow-y-auto pr-2 space-y-4 hidden">
                            <!-- Tower entries will be populated here -->
                        </div>
                        <div id="enemy-index-content" class="flex-grow overflow-y-auto pr-2 space-y-4">
                            <!-- Enemy entries will be populated here -->
                        </div>
                    </div>
                </div>

                <!-- Admin Panel -->
                <div id="admin-panel" class="absolute bottom-4 right-4 bg-gray-800 bg-opacity-90 text-white p-4 rounded-lg shadow-lg w-80 hidden z-50 text-sm">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="font-bold text-lg font-chewy text-amber-400">Admin Panel</h3>
                        <button id="close-admin-panel" class="text-2xl leading-none">&times;</button>
                    </div>
                    <div class="space-y-3 max-h-96 overflow-y-auto pr-2">
                        <!-- Gameplay Controls -->
                        <h4 class="font-bold text-amber-500">Gameplay</h4>
                        <div class="grid grid-cols-3 items-center gap-2">
                            <label for="skip-waves-input">Skip Waves:</label>
                            <input type="number" id="skip-waves-input" class="w-full text-black rounded px-1" value="10">
                            <button id="execute-skip-waves" class="bg-blue-500 hover:bg-blue-600 px-2 py-1 rounded">Execute</button>
                        </div>
                         <div class="grid grid-cols-3 items-center gap-2">
                            <label for="set-wave-input">Set Wave:</label>
                            <input type="number" id="set-wave-input" class="w-full text-black rounded px-1" value="1">
                            <button id="execute-set-wave" class="bg-blue-500 hover:bg-blue-600 px-2 py-1 rounded">Execute</button>
                        </div>
                        <div class="grid grid-cols-3 items-center gap-2">
                            <label for="set-speed-input">Set Speed:</label>
                            <input type="number" id="set-speed-input" class="w-full text-black rounded px-1" step="any" value="1">
                            <button id="execute-set-speed" class="bg-blue-500 hover:bg-blue-600 px-2 py-1 rounded">Execute</button>
                        </div>
                         <div class="grid grid-cols-3 items-center gap-2">
                            <label>Kill On-Screen:</label>
                            <span class="col-span-1"></span>
                            <button id="execute-kill-all" class="bg-red-500 hover:bg-red-600 px-2 py-1 rounded">Execute</button>
                        </div>
                        <div class="grid grid-cols-3 items-center gap-2">
                            <label>Disable Towers:</label>
                            <span class="col-span-1"></span>
                            <button id="execute-disable-towers" class="bg-red-500 hover:bg-red-600 px-2 py-1 rounded">Execute</button>
                        </div>
                         <div class="grid grid-cols-3 items-center gap-2">
                            <label for="spawn-enemy-input">Spawn Enemy:</label>
                             <input type="text" id="spawn-enemy-input" class="w-full text-black rounded px-1" placeholder="Crumb">
                            <button id="execute-spawn-enemy" class="bg-blue-500 hover:bg-blue-600 px-2 py-1 rounded">Execute</button>
                        </div>

                        <hr class="border-gray-600 my-2">
                        <!-- Player Stats -->
                         <h4 class="font-bold text-amber-500">Player Stats</h4>
                        <div class="grid grid-cols-3 items-center gap-2">
                            <label for="add-gold-input">Add Gold:</label>
                            <input type="number" id="add-gold-input" class="w-full text-black rounded px-1" value="1000">
                             <button id="execute-add-gold" class="bg-blue-500 hover:bg-blue-600 px-2 py-1 rounded">Execute</button>
                        </div>
                        <div class="grid grid-cols-3 items-center gap-2">
                            <label for="set-health-input">Set Base Health:</label>
                            <input type="number" id="set-health-input" class="w-full text-black rounded px-1" value="1500">
                             <button id="execute-set-health" class="bg-blue-500 hover:bg-blue-600 px-2 py-1 rounded">Execute</button>
                        </div>
                         <div class="flex items-center gap-2">
                            <input type="checkbox" id="invincible-base-toggle">
                            <label for="invincible-base-toggle">Invincible Base</label>
                        </div>

                        <hr class="border-gray-600 my-2">
                        <!-- Enemy Modifiers -->
                         <h4 class="font-bold text-amber-500">Enemy Modifiers</h4>
                         <div class="grid grid-cols-3 items-center gap-2">
                            <label for="enemy-health-mod-input">Enemy HP x:</label>
                            <input type="number" id="enemy-health-mod-input" class="w-full text-black rounded px-1" step="0.5" value="1">
                             <button id="execute-enemy-health-mod" class="bg-blue-500 hover:bg-blue-600 px-2 py-1 rounded">Execute</button>
                        </div>
                        <div class="grid grid-cols-3 items-center gap-2">
                            <label for="enemy-speed-mod-input">Enemy Speed x:</label>
                            <input type="number" id="enemy-speed-mod-input" class="w-full text-black rounded px-1" step="0.5" value="1">
                             <button id="execute-enemy-speed-mod" class="bg-blue-500 hover:bg-blue-600 px-2 py-1 rounded">Execute</button>
                        </div>
                        
                        <hr class="border-gray-600 my-2">
                        <h4 class="font-bold text-amber-500">Special Commands</h4>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="admin-demon-mode" class="bg-purple-500 hover:bg-purple-600 px-2 py-1 rounded">Demon Mode</button>
                             <button id="admin-hell-mode" class="bg-red-700 hover:bg-red-800 px-2 py-1 rounded">Hell Mode</button>
                             <button id="admin-max-towers" class="bg-yellow-500 hover:bg-yellow-600 px-2 py-1 rounded text-black">Max All Towers</button>
                             <button id="admin-give-all" class="bg-green-500 hover:bg-green-600 px-2 py-1 rounded">Give All Towers</button>
                             <button id="admin-trigger-abilities" class="bg-sky-500 hover:bg-sky-600 col-span-2 px-2 py-1 rounded">Trigger All Abilities</button>
                        </div>

                        <hr class="border-gray-600 my-2">
                        <!-- Visuals -->
                        <h4 class="font-bold text-amber-500">Visuals & Audio</h4>
                        <div class="grid grid-cols-3 items-center gap-2">
                            <label for="grass-color-input">Grass Color:</label>
                            <input type="text" id="grass-color-input" class="w-full text-black rounded px-1" value="#2E8B57">
                            <button id="execute-grass-color" class="bg-blue-500 hover:bg-blue-600 px-2 py-1 rounded">Execute</button>
                        </div>
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="music-toggle">
                            <label for="music-toggle">Enable Music</label>
                        </div>
                    </div>
                </div>

            </div>
            
            <div class="mt-2 text-center flex justify-center items-center gap-2 flex-wrap">
                <div class="flex gap-2">
                    <button id="pause-button" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold p-2 rounded-lg shadow-md w-10 h-10 flex items-center justify-center text-lg">❚❚</button>
                    <button id="normal-speed-button" class="speed-button bg-blue-500 hover:bg-blue-600 text-white font-bold p-2 rounded-lg shadow-md w-10 h-10 active">1x</button>
                    <button id="2x-speed-button" class="speed-button bg-blue-500 hover:bg-blue-600 text-white font-bold p-2 rounded-lg shadow-md w-10 h-10">2x</button>
                </div>
                <button id="index-button" class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">Game Index</button>
                <button id="admin-panel-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105 hidden">Admin</button>
                <button id="sound-toggle-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">🔊 Sound On</button>
                <button id="vote-button" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">Vote</button>
                <button id="save-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">Save Game</button>
                <button id="reset-save-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">Reset Save</button>
            </div>
            
            <!-- Tower Selection Menu -->
            <div class="mt-4 w-full bg-amber-200 border-4 border-amber-400 p-4 rounded-lg shadow-md">
                <h3 class="text-center font-bold text-amber-800 text-xl mb-2">Build a Tower</h3>
                <div id="tower-selection" class="flex justify-center gap-4 flex-wrap">
                    <!-- Tower buttons will be inserted here by JS -->
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="bg-amber-600 py-6">
        <div class="container mx-auto text-center text-white">
            <p>&copy; 2025 Grilled Cheese Tower Defense. All rights reserved.</p>
            <p class="text-sm text-amber-200">A ridiculously cheesy game.</p>
        </div>
    </footer>


    <script>
        // --- ALL THE GAME JAVASCRIPT IS HERE ---

        // --- Canvas and UI Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const parentDiv = canvas.parentElement;

        const goldDisplay = document.getElementById('gold-display');
        const livesDisplay = document.getElementById('lives-display');
        const waveDisplay = document.getElementById('wave-display');
        const timerDisplay = document.getElementById('timer-display');
        const towerSelectionContainer = document.getElementById('tower-selection');
        const soundToggleButton = document.getElementById('sound-toggle-button');
        const pauseButton = document.getElementById('pause-button');
        const normalSpeedButton = document.getElementById('normal-speed-button');
        const twoxSpeedButton = document.getElementById('2x-speed-button');
        const pauseOverlay = document.getElementById('pause-overlay');
        const speedIndicator = document.getElementById('speed-indicator');
        
        const gameOverModal = document.getElementById('game-over-modal');
        const gameOverTitle = document.getElementById('game-over-title');
        const gameOverMessage = document.getElementById('game-over-message');
        const restartButton = document.getElementById('restart-button');
        const bossAlert = document.getElementById('boss-alert');
        const demonModeAlert = document.getElementById('demon-mode-alert');
        const hellModeAlert = document.getElementById('hell-mode-alert');
        
        const indexButton = document.getElementById('index-button');
        const gameIndexModal = document.getElementById('game-index-modal');
        const closeIndexButton = document.getElementById('close-index-button');
        const enemyIndexContent = document.getElementById('enemy-index-content');
        const towerIndexContent = document.getElementById('tower-index-content');
        const showTowersTab = document.getElementById('show-towers-tab');
        const showEnemiesTab = document.getElementById('show-enemies-tab');
        const preGameOverlay = document.getElementById('pre-game-overlay');
        const startGameButton = document.getElementById('start-game-button');
        const playNowButton = document.getElementById('play-now-button');

        const modeSelectModal = document.getElementById('mode-select-modal');
        const normalModeButton = document.getElementById('normal-mode-button');
        const hardModeButton = document.getElementById('hard-mode-button');
        const hardcoreModeButton = document.getElementById('hardcore-mode-button');
        const customModeButton = document.getElementById('custom-mode-button');

        // Custom Game UI
        const customTowerSelectModal = document.getElementById('custom-tower-select-modal');
        const customEnemySelectModal = document.getElementById('custom-enemy-select-modal');
        const customDifficultySelectModal = document.getElementById('custom-difficulty-select-modal');
        const customTowersNextButton = document.getElementById('custom-towers-next-button');
        const customEnemiesBackButton = document.getElementById('custom-enemies-back-button');
        const customEnemiesNextButton = document.getElementById('custom-enemies-next-button');
        const customDifficultyBackButton = document.getElementById('custom-difficulty-back-button');
        const customStartGameButton = document.getElementById('custom-start-game-button');

        // Save/Load UI
        const saveButton = document.getElementById('save-button');
        const resetSaveButton = document.getElementById('reset-save-button');
        const continueButton = document.getElementById('continue-button');
        const continueInfo = document.getElementById('continue-info');
        const modeSelectContainer = document.getElementById('mode-select-container');
        const resetSaveModal = document.getElementById('reset-save-modal');
        const confirmResetButton = document.getElementById('confirm-reset-button');
        const cancelResetButton = document.getElementById('cancel-reset-button');

        // Vote UI
        const voteButton = document.getElementById('vote-button');
        const voteModal = document.getElementById('vote-modal');
        const closeVoteButton = document.getElementById('close-vote-button');
        const voteYesButton = document.getElementById('vote-yes-button');
        const voteNoButton = document.getElementById('vote-no-button');
        const voteBarYes = document.getElementById('vote-bar-yes');
        const voteCountYes = document.getElementById('vote-count-yes');
        const voteCountNo = document.getElementById('vote-count-no');
        
        // Admin Panel UI
        const adminPanelButton = document.getElementById('admin-panel-button');
        const adminPanel = document.getElementById('admin-panel');
        const closeAdminPanel = document.getElementById('close-admin-panel');
        const skipWavesInput = document.getElementById('skip-waves-input');
        const executeSkipWaves = document.getElementById('execute-skip-waves');
        const setWaveInput = document.getElementById('set-wave-input');
        const executeSetWave = document.getElementById('execute-set-wave');
        const setSpeedInput = document.getElementById('set-speed-input');
        const executeSetSpeed = document.getElementById('execute-set-speed');
        const addGoldInput = document.getElementById('add-gold-input');
        const executeAddGold = document.getElementById('execute-add-gold');
        const executeKillAll = document.getElementById('execute-kill-all');
        const setHealthInput = document.getElementById('set-health-input');
        const executeSetHealth = document.getElementById('execute-set-health');
        const invincibleBaseToggle = document.getElementById('invincible-base-toggle');
        const grassColorInput = document.getElementById('grass-color-input');
        const executeGrassColor = document.getElementById('execute-grass-color');
        const musicToggle = document.getElementById('music-toggle');
        const enemyHealthModInput = document.getElementById('enemy-health-mod-input');
        const executeEnemyHealthMod = document.getElementById('execute-enemy-health-mod');
        const enemySpeedModInput = document.getElementById('enemy-speed-mod-input');
        const executeEnemySpeedMod = document.getElementById('execute-enemy-speed-mod');
        const executeDisableTowers = document.getElementById('execute-disable-towers');
        const spawnEnemyInput = document.getElementById('spawn-enemy-input');
        const executeSpawnEnemy = document.getElementById('execute-spawn-enemy');
        const adminDemonMode = document.getElementById('admin-demon-mode');
        const adminHellMode = document.getElementById('admin-hell-mode');
        const adminMaxTowers = document.getElementById('admin-max-towers');
        const adminGiveAll = document.getElementById('admin-give-all');
        const adminTriggerAbilities = document.getElementById('admin-trigger-abilities');


        let canvasWidth, canvasHeight;
        let backgroundCanvas; // Offscreen canvas for the background

        // --- Game State Variables ---
        let gold, wave, waveTimer, gameInterval, timerInterval, frameCount = 0;
        let enemies, towers, projectiles, decorations, floatingTexts, specialEffects, friendlyUnits;
        let gameOver, waveInProgress, bossWave, bossSpawned, demonModeActive, hellModeActive, gameHasStarted = false;
        let selectedTowerType = null, selectedTower = null;
        let mousePos = { x: 0, y: 0 };
        let baseHealth, maxBaseHealth, enemyStrengthModifier, enemySpeedModifier;
        let isBaseInvincible = false;
        let backgroundColor = '#2E8B57';
        let audioStarted = false;
        let isMuted = false;
        let isPaused = false, gameSpeed = 1;
        let keySequence = [];
        let difficultyModifier = { health: 1, speed: 1 };
        let currentDifficulty = 'normal';
        let originalTowerData = {}; // To store original costs
        let isCustomGame = false;
        let customEnabledTowers = [], customEnabledEnemies = [];

        // --- Audio & Music Setup ---
        let popSynth, lazarSynth, explodeSynth, deathSynth, buildSynth, musicSynth, musicLoop;
        let isMusicPlaying = false;
        
        function setupAudio() {
            if (audioStarted) return;
            try {
                Tone.start();
                Tone.Master.mute = isMuted;

                // Sound effects synths
                const popVolume = new Tone.Volume(6).toDestination(); // Increased volume by 6 decibels
                popSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.01, octaves: 6,
                    envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.2 },
                }).connect(popVolume);

                lazarSynth = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination();
                explodeSynth = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.005, decay: 0.3, sustain: 0, release: 0.2 } }).toDestination();
                deathSynth = new Tone.MembraneSynth({ pitchDecay: 0.1, octaves: 2, envelope: { attack: 0.01, decay: 0.3, sustain: 0.01, release: 0.1 }, }).toDestination();
                buildSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.2 } }).toDestination();

                // Music synth and loop
                const musicVolume = new Tone.Volume(-12).toDestination();
                musicSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "triangle8" },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 },
                }).connect(musicVolume);

                const notes = ["C3", "E3", "G3", "B3", "C4", "E4", "G4", "B4"];
                let noteIndex = 0;
                musicLoop = new Tone.Loop(time => {
                    let note = notes[noteIndex % notes.length];
                    musicSynth.triggerAttackRelease(note, "8n", time);
                    noteIndex++;
                }, "8n");
                Tone.Transport.bpm.value = 100;

                audioStarted = true;
            } catch (e) {
                console.error("Audio could not be started:", e);
            }
        }

        function playSound(type) {
            if (!audioStarted || isMuted) return;
            try {
                if (type === 'shoot') popSynth.triggerAttackRelease("C4", "8n");
                if (type === 'lazar') lazarSynth.triggerAttackRelease("G5", "32n");
                if (type === 'explode') explodeSynth.triggerAttack();
                if (type === 'death') deathSynth.triggerAttackRelease("C2", "8n");
                if (type === 'build') buildSynth.triggerAttackRelease("E4", "8n");
            } catch (e) {
                console.error("Sound playback error:", e);
            }
        }

        function toggleMusic() {
            if (!audioStarted) setupAudio();
            isMusicPlaying = !isMusicPlaying;
            if(isMusicPlaying) {
                Tone.Transport.start();
                musicLoop.start(0);
            } else {
                musicLoop.stop(0);
                Tone.Transport.stop();
            }
        }

        function toggleSound() {
            isMuted = !isMuted;
            if (audioStarted) {
                Tone.Master.mute = isMuted;
            }
            soundToggleButton.textContent = isMuted ? '🔇 Sound Off' : '🔊 Sound On';
            soundToggleButton.classList.toggle('bg-gray-500', !isMuted);
            soundToggleButton.classList.toggle('hover:bg-gray-600', !isMuted);
            soundToggleButton.classList.toggle('bg-red-500', isMuted);
            soundToggleButton.classList.toggle('hover:bg-red-600', isMuted);
        }

        // --- Game Configuration ---
        let TOWER_DATA = {};
        function setupTowerData() {
            TOWER_DATA = {
                'gunner': { name: 'Gunner Cheese', cost: 50, range: 0.12, fireRate: 60, damage: 12, projectile: 'normal', upgrade: 'damage', description: 'Your trusty bread-and-butter tower. Fires single, reliable cheese globs.' },
                'slower': { name: 'Slo-mo Melter', cost: 125, range: 0.09, fireRate: 60, damage: 15, projectile: 'slow', upgrade: 'effect', description: 'Launches sticky, melted cheese that significantly slows down enemies.' },
                'gold': { name: 'Gold Grill', cost: 150, range: 0, fireRate: 400, damage: 15, projectile: 'none', upgrade: 'damage', description: 'A passive tower that grills up extra gold for you every few seconds.', limit: 5 },
                'mg': { name: 'Machine Gun Mozz', cost: 175, range: 0.1, fireRate: 10, damage: 10, projectile: 'normal', upgrade: 'fireRate', description: 'Shreds enemies with a blistering fast stream of mozzarella strings.' },
                'bomber': { name: 'Cheddar Bomber', cost: 180, range: 0.15, fireRate: 90, damage: 40, projectile: 'bomb', upgrade: 'damage', description: 'Hurls explosive cheddar balls that deal damage to groups of enemies.' },
                'piercer': { name: 'PepperJack Piercer', cost: 225, range: 0.18, fireRate: 75, damage: 15, projectile: 'pierce', upgrade: 'damage', description: 'Fires a spicy shard of pepperjack that pierces through multiple enemies.' },
                'lazar': { name: 'Lazar Swiss', cost: 250, range: 0.2, fireRate: 120, damage: 120, projectile: 'lazar', upgrade: 'effect', description: 'Channels sunlight through its holes to fire a high-damage laser beam.' },
                'gasser': { name: 'Gorgonzola Gasser', cost: 250, range: 0.1, fireRate: 150, damage: 15, projectile: 'gas_cloud', upgrade: 'effect', description: 'Releases a pungent cloud of gas that deals damage over time to enemies inside.' },
                'fountain': { name: 'Fondue Fountain', cost: 300, range: 0.1, fireRate: 10, damage: 2, projectile: 'none', upgrade: 'damage', description: 'A continuous fountain of hot cheese that damages and slows nearby enemies.' },
                'prism': { name: 'Provolone Prism', cost: 350, range: 0.12, fireRate: 0, damage: 0.25, projectile: 'none', upgrade: 'effect', description: 'A support tower that passively increases the fire rate of all towers in its radius.' },
                'rocket': { name: 'Ricotta Rocket', cost: 400, range: 0.25, fireRate: 240, damage: 200, projectile: 'rocket', upgrade: 'damage', description: 'Launches a long-range rocket with a large and powerful explosion.' },
                'partitioner': { name: 'Parmesan Partitioner', cost: 450, range: 0.15, fireRate: 100, damage: 50, projectile: 'bounce', upgrade: 'damage', description: 'Fires a hard parmesan disc that ricochets between several enemies.' },
                'blue_bio': { name: 'Blue Cheese Bio-Tower', cost: 500, range: 0.15, fireRate: 100, damage: 20, projectile: 'gas_cloud', upgrade: 'effect', description: 'Spreads a virulent mold cloud that deals significant damage over time.' },
                'colby_coin_op': { name: 'Colby Coin-op', cost: 520, range: 0, fireRate: 240, damage: 25, projectile: 'none', upgrade: 'cash', description: 'A reliable investment that generates a steady stream of gold.', limit: 3 },
                'blimp': { name: 'Brie Blimp', cost: 550, range: 1.0, fireRate: 180, damage: 150, projectile: 'brie_rocket', upgrade: 'damage', description: 'Launches a powerful rocket in a straight line towards a target.' },
                'assassin': { name: 'Asiago Assassin', cost: 600, range: 0.3, fireRate: 120, damage: 150, projectile: 'normal', upgrade: 'damage', description: 'Focuses on a single target, dealing more damage the longer it attacks it.' },
                'havarti_harpoon': { name: 'Havarti Harpoon', cost: 625, range: 0.2, fireRate: 150, damage: 50, projectile: 'harpoon', upgrade: 'effect', description: 'Fires a harpoon that drags an enemy back a short distance.'},
                'hailstorm': { name: 'Havarti Hailstorm', cost: 650, range: 0.15, fireRate: 200, damage: 10, projectile: 'none', upgrade: 'effect', description: 'Creates a damaging hailstorm with a chance to briefly freeze enemies.' },
                'freezer': { name: 'Feta Freezer', cost: 700, range: 0.2, fireRate: 200, damage: 150, projectile: 'freeze', upgrade: 'effect', description: 'Fires a shard of feta that completely freezes a target for a moderate duration.' },
                'commander': { name: 'Colby Commander', cost: 750, range: 0, fireRate: 0, damage: 0.08, projectile: 'none', upgrade: 'effect', description: 'A global command tower that provides a small fire rate and range buff to all towers.' },
                'gouda_guardian': { name: 'Gouda Guardian', cost: 800, range: 0.1, fireRate: 20, damage: 30, projectile: 'normal', upgrade: 'damage', description: 'A powerful short-range defender that fires a spread of three projectiles.' },
                'monolith': { name: 'Muenster Monolith', cost: 850, range: 0, fireRate: 0, damage: 0, projectile: 'none', upgrade: 'health', description: 'A defensive wall placed on the path. It has its own health and must be destroyed by enemies.', health: 75, maxHealth: 75, thornsUpgradeCost: 250, healthUpgradeCost: 200 },
                'asiago_accelerator': { name: 'Asiago Accelerator', cost: 900, range: 0.1, fireRate: 0, damage: 0.15, projectile: 'none', upgrade: 'effect', description: 'A support tower that passively increases the damage of all towers in its radius by 15%.'},
                'colby_cannon': { name: 'Colby Cannon', cost: 1000, range: 0.18, fireRate: 40, damage: 20, projectile: 'bomb', upgrade: 'fireRate', description: 'A fast-firing cannon that deals small area-of-effect damage.'},
                'romano_repeater': { name: 'Romano Repeater', cost: 1100, range: 0.2, fireRate: 30, damage: 25, projectile: 'bounce', upgrade: 'fireRate', description: 'Rapidly fires multiple projectiles that bounce between enemies.' },
                'mimolette_mint': { name: 'Mimolette Mint', cost: 1123, range: 0, fireRate: 180, damage: 50, projectile: 'none', upgrade: 'cash', description: 'A more advanced gold generator that prints money faster.', limit: 2 },
                'manchego_mortar': { name: 'Manchego Mortar', cost: 1500, range: 0.4, fireRate: 300, damage: 300, projectile: 'bomb', upgrade: 'damage', description: 'A very long-range artillery tower with a massive explosive impact.' },
                'chevre_chain': { name: 'Chevre Chain Lightning', cost: 1800, range: 0.25, fireRate: 75, damage: 100, projectile: 'bounce', upgrade: 'damage', description: 'Zaps a primary target with lightning that then arcs to many nearby enemies.' },
                'pecorino_pulverizer': { name: 'Pecorino Pulverizer', cost: 2200, range: 0.1, fireRate: 45, damage: 200, projectile: 'normal', upgrade: 'damage', description: 'A heavy-hitting tower that excels at taking down single, powerful enemies.' },
                'monterey_minefield': { name: 'Monterey Minefield', cost: 2500, range: 0, fireRate: 400, damage: 500, projectile: 'mine', upgrade: 'damage', description: 'Periodically places a high-damage explosive mine on the track.'},
                'camembert_comet': { name: 'Camembert Comet', cost: 2700, range: 0.5, fireRate: 480, damage: 1000, projectile: 'rocket', upgrade: 'damage', description: 'Targets the densest group of enemies and calls down a devastating comet.' },
                'brie_barrage': { name: 'Brie Barrage', cost: 3500, range: 0.3, fireRate: 5, damage: 15, projectile: 'slow', upgrade: 'fireRate', description: 'Fills the screen with an overwhelming number of slowing projectiles.' },
                'muenster_monster': { name: 'Muenster Monster', cost: 4000, range: 0, fireRate: 600, damage: 100, projectile: 'spawn_golem', upgrade: 'effect', description: 'Spawns a temporary Muenster Golem on the track to fight enemies head-on.'},
                'swiss_behemoth': { name: 'Swiss Behemoth', cost: 5000, range: 0.25, fireRate: 30, damage: 1200, projectile: 'bomb', upgrade: 'damage', description: 'Flings giant, explosive wheels of swiss cheese out in a spinning pattern.' },
                'vacherin_vault': { name: 'Vacherin Vault', cost: 5500, range: 0, fireRate: 120, damage: 150, projectile: 'none', upgrade: 'cash', description: 'The ultimate economic tower, generating vast quantities of gold.', limit: 1 },
                'gruyere_golem': { name: 'Gruyere Golem', cost: 6000, range: 0.25, fireRate: 90, damage: 3200, projectile: 'stun', upgrade: 'damage', description: 'A slow but incredibly powerful tower whose attacks can stun enemies.' },
                'ricotta_refractor': { name: 'Ricotta Refractor', cost: 6500, range: 0.22, fireRate: 80, damage: 500, projectile: 'chain_decay', upgrade: 'damage', description: 'Fires a beam that chains to multiple enemies, but each jump reduces its damage.'},
                'limburger_lazer': { name: 'Limburger Lazer', cost: 7500, range: 0.4, fireRate: 5, damage: 450, projectile: 'continuous_lazar', upgrade: 'damage', description: 'Projects a continuous, high-damage laser that melts everything in its path.' },
                'edam_eradicator': { name: 'Edam Eradicator', cost: 9000, range: 0.5, fireRate: 90, damage: 3600, projectile: 'shock_blast', upgrade: 'fireRate', description: 'Charges up and releases a massive blast of energy, shocking and damaging enemies.' },
                'morbier_maelstrom': { name: 'Morbier Maelstrom', cost: 10500, range: 0.35, fireRate: 20, damage: 900, projectile: 'vortex', upgrade: 'effect', description: 'Creates a powerful vortex that damages and slows all enemies in its radius.' },
                'burrata_bomber': { name: 'Burrata Bomber', cost: 12000, range: 0.5, fireRate: 240, damage: 4500, projectile: 'carpet_bomb', upgrade: 'damage', description: 'Calls in a bombing run that carpets a section of the path with explosions.' },
                
                // Buffed Towers Start Here
                'stinking_bishops_smite': { name: 'Stinking Bishop\'s Smite', cost: 60000, range: 0.5, fireRate: 400, damage: 50000, projectile: 'smite_beam', upgrade: 'damage', description: 'Calls a holy beam to smite a target, leaving them burning with holy fire.' },
                'valdeon_vortex': { name: 'Valdeon Vortex', cost: 65000, range: 0.4, fireRate: 80, damage: 12000, projectile: 'super_vortex', upgrade: 'effect', description: 'A powerful vortex that pulls in and shreds enemies. Survivors are permanently slowed.' },
                'casu_marzus_call': { name: 'Casu Marzu\'s Call', cost: 70000, range: 0, fireRate: 500, damage: 250, projectile: 'spawn_maggots', upgrade: 'effect', description: 'Spawns friendly cheese maggots on the track that seek and destroy enemies.' },
                'halloumi_hellstorm': { name: 'Halloumi Hell-storm', cost: 75000, range: 0.5, fireRate: 350, damage: 15000, projectile: 'fire_storm', upgrade: 'damage', description: 'Rains down fiery halloumi over a large area, leaving the ground scorched and burning.' },
                'stilton_supernova': { name: 'Stilton Supernova', cost: 90000, range: 0.6, fireRate: 600, damage: 40000, projectile: 'supernova_blast', upgrade: 'damage', description: 'Unleashes a massive, stunning explosion, obliterating lesser foes.' },
                'gouda_god-hand': { name: 'Gouda God-Hand', cost: 110000, range: 0.5, fireRate: 500, damage: 100000, projectile: 'god_hand', upgrade: 'damage', description: 'Summons a giant hand to slam enemies, with a chance to instantly crush non-bosses.' },
                'cheddar_cataclysm': { name: 'Cheddar Cataclysm', cost: 125000, range: 0, fireRate: 700, damage: 25000, projectile: 'screen_shake_damage', upgrade: 'damage', description: 'Causes a screen-shattering earthquake, damaging and slowing all enemies.' },
                'brie_black_hole': { name: 'Brie Black Hole', cost: 140000, range: 0.5, fireRate: 750, damage: 35000, projectile: 'black_hole', upgrade: 'effect', description: 'Creates a black hole that pulls in and destroys nearby enemies.' },
                'mozzarella_moonfall': { name: 'Mozzarella Moonfall', cost: 160000, range: 1.0, fireRate: 1000, damage: 250000, projectile: 'moonfall', upgrade: 'damage', description: 'Drops a literal moon of mozzarella, leaving a slowing crater.' },
                'provolone_pandemic': { name: 'Provolone Pandemic', cost: 180000, range: 0.4, fireRate: 100, damage: 10000, projectile: 'infection_explosion', upgrade: 'effect', description: 'Infects an enemy with a plague that spreads explosively when the host is defeated.' },
                'feta_freeze-frame': { name: 'Feta Freeze-Frame', cost: 200000, range: 0, fireRate: 1200, damage: 20000, projectile: 'global_freeze', upgrade: 'effect', description: 'Freezes every enemy on screen, making them vulnerable to extra damage.' },
                'swiss_singularity': { name: 'Swiss Singularity', cost: 225000, range: 0.5, fireRate: 700, damage: 50000, projectile: 'super_vortex', upgrade: 'effect', description: 'A stronger, permanent black hole that devastates everything near it.' },
                'parmesan_paradox': { name: 'Parmesan Paradox', cost: 250000, range: 1.0, fireRate: 300, damage: 5000, projectile: 'rewind_group', upgrade: 'effect', description: 'Sends a group of the strongest enemies back to the start, weakened.' },

                // Original Towers
                'pule_pummeler': { name: 'Pule Pummeler', cost: 80000, range: 0.3, fireRate: 180, damage: 30000, projectile: 'super_pierce', upgrade: 'damage', description: 'The most expensive cheese in the world, fired as a high-velocity piercing projectile.' },
                'pont-leveque_portal': { name: 'Pont-l\'Évêque Portal', cost: 85000, range: 0.4, fireRate: 240, damage: 1000, projectile: 'teleport_blast', upgrade: 'effect', description: 'Has a chance to open a portal that sends enemies back to the start.' },
                'roquefort_rift': { name: 'Roquefort Rift', cost: 95000, range: 0.4, fireRate: 60, damage: 2000, projectile: 'rift', upgrade: 'effect', description: 'Tears a rift in reality on the path that deals massive damage over time.' },
                'the_cheesus_christ': { name: 'The Cheesus Christ', cost: 500000, range: 1.0, fireRate: 1800, damage: 999999, projectile: 'rapture', upgrade: 'damage', description: 'The final prayer. Erases all non-boss enemies from existence.' }
            };
        }
        setupTowerData(); // Initial setup
        originalTowerData = JSON.parse(JSON.stringify(TOWER_DATA)); // Deep copy for resetting

        const ENEMY_DATA = { 
            'normal': { health: 40, speed: 0.6, gold: 10 }, 
            'scout': { health: 25, speed: 1.2, gold: 7 },
            'bruiser': { health: 200, speed: 0.3, gold: 20 },
            'popper': { health: 50, speed: 0.7, gold: 15, onDeath: 'explode', damage: 50, radius: 0.05 },
            'moldy': { health: 60, speed: 0.5, gold: 22, onDeath: 'disable', radius: 0.05, duration: 180 },
            'pbj': { health: 80, speed: 0.5, gold: 50, resistance: 'slow' },
            'goliath': { health: 1000, speed: 0.2, gold: 100 },
            'medic': { health: 150, speed: 0.6, gold: 40, ability: 'regenerate', regenRate: 5 },
            'speeder': { health: 50, speed: 2.5, gold: 30 },
            'breeder': { health: 200, speed: 0.5, gold: 50, onDeath: 'spawn', spawnType: 'scout', spawnCount: 2 },
            'saboteur': { health: 100, speed: 0.7, gold: 60, onDeath: 'disable', radius: 0.1, duration: 360 },
            'boss': { health: 4000, speed: 0.25, gold: 750 },
            'burnt_beast': { health: 6000, speed: 0.2, gold: 1000, resistance: ['burn'] },
            'moldy_monarch': { health: 3500, speed: 0.3, gold: 850, onDeath: 'disable_large', radius: 0.2, duration: 600 },
            'ghost_pepper': { health: 10, speed: 3.0, gold: 25, ability: 'fire_trail' },
            'teleporter': { health: 100, speed: 0.8, gold: 45, ability: 'teleport' },
            'healer': { health: 300, speed: 0.4, gold: 35, ability: 'heal_aura' },
            'thief': { health: 75, speed: 1.5, gold: 10, ability: 'steal' },
            'mimic': { health: 2500, speed: 0.6, gold: 200 },
            'splitter': { health: 150, speed: 0.7, gold: 25, ability: 'split' },
            'phasing': { health: 120, speed: 0.9, gold: 55, ability: 'phase' },
            'general': { health: 500, speed: 0.5, gold: 120, ability: 'speed_aura' },
            'kamikaze': { health: 20, speed: 2.8, gold: 15, onDeath: 'explode_kamikaze', damage: 150, radius: 0.07 },
            'frost_crumb': { health: 150, speed: 0.6, gold: 40, resistance: ['slow', 'freeze'] },
            'shadow_crumb': { health: 80, speed: 1.0, gold: 30, ability: 'shadow_step' },
            'vampire_crumb': { health: 250, speed: 0.7, gold: 40, ability: 'lifesteal' },
            'glass_crumb': { health: 5, speed: 4.0, gold: 15 },
            'sponge_crumb': { health: 300, speed: 0.4, gold: 35, ability: 'absorb', absorbCharges: 3 },
            'cursed_crumb': { health: 180, speed: 0.6, gold: 28, onDeath: 'curse', duration: 300, effect: 0.5 },
            'swarm_host': { health: 500, speed: 0, gold: 100, ability: 'spawn_swarm' },
            'oracle_crumb': { health: 400, speed: 0.5, gold: 70, ability: 'grant_immunity' },
            'titan_crumb': { health: 2000, speed: 0.25, gold: 150, resistance: ['normal'], weakness: 'bomb' },
            'clone_crumb': { health: 100, speed: 0.8, gold: 20, onDeath: 'clone', cloneCount: 2 },
            'assassin_crumb': { health: 50, speed: 2.0, gold: 50, ability: 'rush_base' },
            'juggernaut_crumb': { health: 500, speed: 0.3, gold: 80, ability: 'enrage' },
            'king_crumb': { health: 3000, speed: 0.3, gold: 250, ability: 'buff_aura' }
        };

        const ENEMY_DESCRIPTIONS = {
            'normal': { name: 'Crumb', description: 'A basic, everyday crumb. Not much of a threat alone.' },
            'scout': { name: 'Crouton Scout', description: 'Fast and crunchy, these scouts rush ahead of the main force.' },
            'bruiser': { name: 'Burnt Bit', description: 'Slow but tough. These overcooked morsels can take a lot of heat.' },
            'popper': { name: 'Jalapeño Popper', description: 'Spicy and volatile. Explodes upon defeat, damaging nearby towers.' },
            'moldy': { name: 'Moldy Morsel', description: 'Disgusting and debilitating. Disables the tower that defeats it.' },
            'pbj': { name: 'PB&J Crust', description: 'A strange, sweet and savory hybrid with surprising resilience. Resistant to slowing effects.' },
            'goliath': { name: 'Goliath Crumb', description: 'An absolute unit of a crumb. Extremely high health.' },
            'medic': { name: 'Milk Globule', description: 'A splash of milk that constantly regenerates its health.' },
            'speeder': { name: 'Grease Streak', description: 'A slippery, fast-moving enemy that zips along the path.' },
            'breeder': { name: 'Dough Ball', description: 'Uncooked and unstable. Splits into two smaller scouts when defeated.' },
            'saboteur': { name: 'Soggy Spot', description: 'A dreadful spill that disables all nearby towers upon its demise.' },
            'boss': { name: 'The Big Cheese', description: 'The leader of the hungry horde. A massive, molten monstrosity.' },
            'burnt_beast': { name: 'The Burnt Beast', description: 'A colossal, charred crust that is completely immune to fire and burning effects. Incredibly durable.' },
            'moldy_monarch': { name: 'The Moldy Monarch', description: 'A sentient colony of mold. Upon defeat, it releases a massive cloud of spores, disabling all towers in a huge radius for a long time.' },
            'ghost_pepper': { name: 'Ghost Pepper Flake', description: 'Extremely fast with low health. Leaves a trail of fire that damages towers over time.' },
            'teleporter': { name: 'Sesame Seed', description: 'Moves normally, but occasionally blinks forward a short distance along the path.' },
            'healer': { name: 'Cream Cheese Dollop', description: 'Slowly moves along the path, healing nearby enemies with its creamy goodness.' },
            'thief': { name: 'Greedy Grater', description: 'Instead of damaging the base, it steals a chunk of your gold when it reaches the end.' },
            'mimic': { name: 'Mimic Crumb', description: 'Looks like a normal crumb, but has a deceptively large amount of health.' },
            'splitter': { name: 'Sourdough Starter', description: 'Splits into two smaller, faster versions of itself after taking enough damage.' },
            'phasing': { name: 'Swiss Ghost', description: 'Periodically becomes transparent and immune to all projectiles for a short time.' },
            'general': { name: 'Captain Crouton', description: 'A tough leader that provides a speed aura to all nearby enemies.' },
            'kamikaze': { name: 'Pop Rock', description: 'Ignores the path and flies directly towards the nearest tower, exploding on impact.' },
            'frost_crumb': { name: 'Frozen Breadcrumb', description: 'An icy morsel from the back of the freezer. Immune to all slowing and freezing effects.' },
            'shadow_crumb': { name: 'Shadow Crumb', description: 'Teleports randomly when hit, making it hard to pin down.'},
            'vampire_crumb': { name: 'Vampire Crumb', description: 'Heals itself for 10x the damage it deals to your base.'},
            'glass_crumb': { name: 'Glass Crumb', description: 'Extremely fast, but shatters in a single hit.'},
            'sponge_crumb': { name: 'Sponge Crumb', description: 'Has a protective shield that absorbs the first 3 hits.'},
            'cursed_crumb': { name: 'Cursed Crumb', description: 'Upon death, it curses the tower that killed it, halving its damage for 5 seconds.'},
            'swarm_host': { name: 'Swarm Host', description: 'A stationary enemy that continuously spawns tiny, weak crumbs.'},
            'oracle_crumb': { name: 'Oracle Crumb', description: 'Grants nearby enemies a temporary shield against a random projectile type.'},
            'titan_crumb': { name: 'Titan Crumb', description: 'Resistant to normal projectiles, but takes double damage from explosions.'},
            'clone_crumb': { name: 'Clone Crumb', description: 'Splits into two identical, but weaker, copies upon death.'},
            'assassin_crumb': { name: 'Assassin Crumb', description: 'Ignores the path and makes a beeline for your base. Very fast, but frail.'},
            'juggernaut_crumb': { name: 'Juggernaut Crumb', description: 'Moves faster and deals more damage to the base the lower its health is.'},
            'king_crumb': { name: 'King Crumb', description: 'A mini-boss that grants a damage and speed aura to all other enemies on screen.'}
        };

        const path = [ { x: -0.05, y: 0.1 }, { x: 0.25, y: 0.1 }, { x: 0.25, y: 0.5 }, { x: 0.1, y: 0.5 }, { x: 0.1, y: 0.8 }, { x: 0.4, y: 0.8 }, { x: 0.4, y: 0.3 }, { x: 0.7, y: 0.3 }, { x: 0.7, y: 0.9 }, { x: 0.9, y: 0.9 }, { x: 0.9, y: 0.1 }, { x: 1.05, y: 0.1 } ];
        let scaledPath = [];
        const adminCode = ['a', 'd', 'm', 'i', 'n', '1', '2', '3'];

        // --- Drawing Functions ---
        function drawTower(tower, targetCtx = ctx) {
            const { x, y, size, type, level } = tower; 
            targetCtx.lineWidth = 2; targetCtx.strokeStyle = 'rgba(0,0,0,0.5)';
            if (tower.disabled > 0) { targetCtx.globalAlpha = 0.5; }
            
            targetCtx.save();
            targetCtx.translate(x, y);

            // --- TOWER REDESIGNS ---
            if (type === 'gunner') {
                // Base
                targetCtx.fillStyle = '#D2B48C';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeRect(-size/2, -size/2, size, size);
                // Cheese
                targetCtx.fillStyle = '#FFD700';
                targetCtx.fillRect(-size/2 + 4, -size/2 + 4, size - 8, size - 8);
                // Barrel
                targetCtx.fillStyle = '#696969';
                targetCtx.fillRect(-4, -size/2 - 8, 8, 12);
            } else if (type === 'havarti_harpoon') {
                 targetCtx.fillStyle = '#f7f1e3';
                 targetCtx.fillRect(-size/2, -size/2, size, size);
                 targetCtx.strokeRect(-size/2, -size/2, size, size);
                 targetCtx.fillStyle = '#706fd3';
                 targetCtx.beginPath();
                 targetCtx.moveTo(0, -size/2);
                 targetCtx.lineTo(size/4, size/2);
                 targetCtx.lineTo(-size/4, size/2);
                 targetCtx.closePath();
                 targetCtx.fill();
            } else if (type === 'asiago_accelerator') {
                 targetCtx.fillStyle = '#f1c40f';
                 targetCtx.beginPath();
                 targetCtx.arc(0, 0, size/2, 0, Math.PI * 2);
                 targetCtx.fill();
                 targetCtx.fillStyle = 'white';
                 targetCtx.font = `bold ${size/1.5}px sans-serif`;
                 targetCtx.textAlign = 'center';
                 targetCtx.textBaseline = 'middle';
                 targetCtx.fillText('+', 0, 2);
            } else if (type === 'colby_cannon') {
                 targetCtx.fillStyle = '#e67e22';
                 targetCtx.beginPath();
                 targetCtx.arc(0, 0, size/2, 0, Math.PI * 2);
                 targetCtx.fill();
                 targetCtx.fillStyle = '#3d3d3d';
                 targetCtx.beginPath();
                 targetCtx.arc(0, 0, size/3, 0, Math.PI * 2);
                 targetCtx.fill();
                 targetCtx.fillRect(-4, -size/2 - 8, 8, 12);
            } else if (type === 'ricotta_refractor') {
                 targetCtx.fillStyle = '#ecf0f1';
                 targetCtx.beginPath();
                 targetCtx.moveTo(0, -size/2);
                 targetCtx.lineTo(size/2, size/4);
                 targetCtx.lineTo(-size/2, size/4);
                 targetCtx.closePath();
                 targetCtx.fill();
                 targetCtx.stroke();
                 targetCtx.fillStyle = '#3498db';
                 targetCtx.beginPath();
                 targetCtx.arc(0, -size/4, size/6, 0, Math.PI * 2);
                 targetCtx.fill();
            } else if (type === 'monterey_minefield') {
                 targetCtx.fillStyle = '#2c3e50';
                 targetCtx.fillRect(-size/2, -size/4, size, size/2);
                 targetCtx.fillStyle = '#e74c3c';
                 targetCtx.beginPath();
                 targetCtx.arc(0, 0, size/4, 0, Math.PI * 2);
                 targetCtx.fill();
            } else if (type === 'muenster_monster') {
                targetCtx.fillStyle = '#d35400';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 2, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.fillStyle = 'black';
                targetCtx.font = `bold ${size/2}px sans-serif`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                targetCtx.fillText('M', 0, 2);
            } else if (type === 'mg') {
                // Base
                targetCtx.fillStyle = '#E0E0E0';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.stroke();
                // Barrels
                targetCtx.fillStyle = '#555';
                targetCtx.fillRect(0, -2, size/2 + 5, 4);
                targetCtx.fillRect(-2, size/2 - 10, 4, size/2 + 5);
                 targetCtx.fillRect(-2, -size/2 - 5, 4, size/2 - 10);
            } else if (type === 'lazar') {
                // Base
                targetCtx.fillStyle = '#BDB76B';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeRect(-size/2, -size/2, size, size);
                // Crystal
                targetCtx.fillStyle = 'cyan';
                targetCtx.beginPath();
                targetCtx.moveTo(0, -size/2);
                targetCtx.lineTo(size/4, 0);
                targetCtx.lineTo(0, size/4);
                targetCtx.lineTo(-size/4, 0);
                targetCtx.closePath();
                targetCtx.fill();
            } else if (type === 'bomber') {
                // Base
                targetCtx.fillStyle = '#FFA500';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.stroke();
                // Catapult arm
                targetCtx.fillStyle = '#8B4513';
                targetCtx.fillRect(-4, -size/2, 8, size);
            } else if (type === 'slower') {
                targetCtx.fillStyle = '#3498DB'; // Blue
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeStyle = 'white';
                targetCtx.lineWidth = 2;
                targetCtx.beginPath();
                targetCtx.moveTo(-size/2, 0);
                targetCtx.quadraticCurveTo(-size/4, -size/4, 0, 0);
                targetCtx.quadraticCurveTo(size/4, size/4, size/2, 0);
                targetCtx.stroke();
            } else if (type === 'gold' || type === 'colby_coin_op' || type === 'mimolette_mint' || type === 'vacherin_vault') {
                let baseColor = '#FFD700'; // Lighter yellow for Gold Grill
                if (type === 'colby_coin_op') baseColor = '#F39C12'; // Orange
                if (type === 'mimolette_mint') baseColor = '#E67E22'; // Darker Orange
                if (type === 'vacherin_vault') baseColor = '#FDEBD0'; // Cream
                targetCtx.fillStyle = baseColor;
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 2, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.stroke();
                targetCtx.fillStyle = 'black';
                targetCtx.font = `bold ${size/1.5}px Inter`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                targetCtx.fillText('$', 0, 2);
            } else if (type === 'piercer') {
                targetCtx.fillStyle = '#E74C3C'; // Red
                targetCtx.beginPath();
                targetCtx.moveTo(0, -size/1.5);
                targetCtx.lineTo(size/2, size/2);
                targetCtx.lineTo(-size/2, size/2);
                targetCtx.closePath();
                targetCtx.fill();
                targetCtx.stroke();
            } else if (type === 'gasser') {
                targetCtx.fillStyle = '#2ECC71'; // Green
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 2, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.fillStyle = 'rgba(255,255,255,0.5)';
                targetCtx.beginPath();
                targetCtx.arc(size/4, -size/4, size/6, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.beginPath();
                targetCtx.arc(-size/4, size/4, size/8, 0, Math.PI * 2);
                targetCtx.fill();
            } else if (type === 'fountain') {
                targetCtx.fillStyle = '#E67E22'; // Orange
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 2, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.fillStyle = '#F39C12';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 3, 0, Math.PI * 2);
                targetCtx.fill();
            } else if (type === 'prism') {
                targetCtx.fillStyle = '#9B59B6'; // Purple
                targetCtx.beginPath();
                targetCtx.moveTo(0, -size/2);
                targetCtx.lineTo(size/2, 0);
                targetCtx.lineTo(0, size/2);
                targetCtx.lineTo(-size/2, 0);
                targetCtx.closePath();
                targetCtx.fill();
                targetCtx.stroke();
            } else if (type === 'rocket') {
                targetCtx.fillStyle = '#95A5A6'; // Grey
                targetCtx.beginPath();
                targetCtx.moveTo(0, -size/1.5);
                targetCtx.lineTo(size/2, size/2);
                targetCtx.lineTo(-size/2, size/2);
                targetCtx.closePath();
                targetCtx.fill();
                targetCtx.fillStyle = '#E74C3C'; // Red tip
                targetCtx.beginPath();
                targetCtx.moveTo(0, -size/1.5);
                targetCtx.lineTo(size/4, -size/2);
                targetCtx.lineTo(-size/4, -size/2);
                targetCtx.closePath();
                targetCtx.fill();
            } else if (type === 'partitioner') {
                targetCtx.fillStyle = '#ECF0F1'; // White
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 2, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.stroke();
                targetCtx.fillStyle = '#34495E';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 4, 0, Math.PI * 2);
                targetCtx.fill();
            } else if (type === 'monolith') {
                targetCtx.fillStyle = '#34495E'; // Dark blue/grey
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeRect(-size/2, -size/2, size, size);
                
                // Monolith health bar
                if (tower.health > 0) {
                    const barWidth = size;
                    targetCtx.fillStyle = '#DC2626'; // Red background
                    targetCtx.fillRect(-barWidth / 2, -size/2 - 15, barWidth, 8);
                    targetCtx.fillStyle = '#22C55E'; // Green health
                    targetCtx.fillRect(-barWidth / 2, -size/2 - 15, barWidth * (tower.health / tower.maxHealth), 8);
                }
            } else if (type === 'blimp') {
                targetCtx.fillStyle = '#BDC3C7'; // Silver
                targetCtx.beginPath();
                targetCtx.ellipse(0, 0, size/1.5, size/2.5, 0, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.stroke();
                targetCtx.fillStyle = '#34495E';
                targetCtx.fillRect(-size/3, size/2.5 - 5, size*2/3, 10);
            } else if (type === 'assassin') {
                targetCtx.fillStyle = '#2C3E50'; // Very dark blue
                targetCtx.beginPath();
                targetCtx.moveTo(0, -size/2);
                targetCtx.lineTo(size/2, size/2);
                targetCtx.lineTo(0, size/4);
                targetCtx.lineTo(-size/2, size/2);
                targetCtx.closePath();
                targetCtx.fill();
            } else if (type === 'hailstorm') {
                targetCtx.fillStyle = '#3498DB'; // Blue
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 2, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.fillStyle = 'rgba(255,255,255,0.7)';
                for(let i=0; i<5; i++) {
                    targetCtx.beginPath();
                    targetCtx.arc((Math.random()-0.5)*size/2, (Math.random()-0.5)*size/2, size/8, 0, Math.PI*2);
                    targetCtx.fill();
                }
            } else if (type === 'freezer') {
                targetCtx.fillStyle = '#A9CCE3'; // Light blue
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeStyle = 'white';
                targetCtx.lineWidth = 3;
                targetCtx.beginPath();
                targetCtx.moveTo(-size/2, 0); targetCtx.lineTo(size/2, 0);
                targetCtx.moveTo(0, -size/2); targetCtx.lineTo(0, size/2);
                targetCtx.moveTo(-size/3, -size/3); targetCtx.lineTo(size/3, size/3);
                targetCtx.moveTo(size/3, -size/3); targetCtx.lineTo(-size/3, size/3);
                targetCtx.stroke();
            } else if (type === 'commander') {
                targetCtx.fillStyle = '#F1C40F'; // Gold
                targetCtx.beginPath();
                targetCtx.moveTo(0, -size/2);
                for (let i = 1; i < 5; i++) {
                    const angle = i * Math.PI * 0.4;
                    targetCtx.lineTo(Math.sin(angle) * size/2, -Math.cos(angle) * size/2);
                    const innerAngle = angle + Math.PI * 0.2;
                    targetCtx.lineTo(Math.sin(innerAngle) * size/4, -Math.cos(innerAngle) * size/4);
                }
                targetCtx.closePath();
                targetCtx.fill();
            } else if (type === 'gouda_guardian') {
                targetCtx.fillStyle = '#F39C12'; // Orange
                targetCtx.beginPath();
                targetCtx.moveTo(-size/2, -size/2);
                targetCtx.lineTo(size/2, -size/2);
                targetCtx.lineTo(size/2, size/4);
                targetCtx.lineTo(0, size/2);
                targetCtx.lineTo(-size/2, size/4);
                targetCtx.closePath();
                targetCtx.fill();
                targetCtx.stroke();
            } else if (type === 'blue_bio') {
                targetCtx.fillStyle = '#2980B9'; // Blue
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 2, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.strokeStyle = 'yellow';
                targetCtx.lineWidth = 2;
                targetCtx.beginPath();
                targetCtx.arc(0,0, size/4, 0, Math.PI*2);
                targetCtx.moveTo(size/4, 0); targetCtx.arc(0,0, size/4, 0, Math.PI*2/3, false);
                targetCtx.moveTo(size/4, 0); targetCtx.arc(0,0, size/4, Math.PI, Math.PI*5/3, false);
                targetCtx.moveTo(size/4, 0); targetCtx.arc(0,0, size/4, Math.PI*2/3, Math.PI*4/3, true);
                targetCtx.stroke();
            } else if (type === 'romano_repeater') {
                targetCtx.fillStyle = '#7F8C8D'; // Grey
                targetCtx.fillRect(-size/2, -size/4, size, size/2);
                targetCtx.strokeRect(-size/2, -size/4, size, size/2);
                targetCtx.fillStyle = '#34495E';
                targetCtx.fillRect(size/4, -size/2, 4, size);
                targetCtx.fillRect(-size/4-4, -size/2, 4, size);
            } else if (type === 'manchego_mortar') {
                targetCtx.fillStyle = '#D35400'; // Dark orange
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.stroke();
                targetCtx.fillStyle = '#34495E';
                targetCtx.save();
                targetCtx.rotate(Math.PI / 4);
                targetCtx.fillRect(-size/6, -size/2, size/3, size);
                targetCtx.restore();
            } else if (type === 'chevre_chain') {
                targetCtx.fillStyle = '#ECF0F1'; // White
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.strokeStyle = 'yellow';
                targetCtx.lineWidth = 3;
                targetCtx.beginPath();
                targetCtx.moveTo(-size/3, -size/2);
                targetCtx.lineTo(size/6, 0);
                targetCtx.lineTo(-size/6, 0);
                targetCtx.lineTo(size/3, size/2);
                targetCtx.stroke();
            } else if (type === 'pecorino_pulverizer') {
                targetCtx.fillStyle = '#BDC3C7'; // Silver
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeRect(-size/2, -size/2, size, size);
                targetCtx.fillStyle = '#7F8C8D';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 3, 0, Math.PI * 2);
                targetCtx.fill();
            } else if (type === 'camembert_comet') {
                targetCtx.fillStyle = '#1ABC9C'; // Teal
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.fillStyle = 'white';
                targetCtx.beginPath();
                targetCtx.moveTo(-size/3, -size/3);
                targetCtx.lineTo(0, -size/2);
                targetCtx.lineTo(size/3, -size/3);
                targetCtx.lineTo(0, 0);
                targetCtx.closePath();
                targetCtx.fill();
            } else if (type === 'brie_barrage') {
                targetCtx.fillStyle = '#FDFEFE'; // Off-white
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeRect(-size/2, -size/2, size, size);
                targetCtx.fillStyle = '#566573';
                for(let i=0; i<3; i++) {
                    for(let j=0; j<3; j++) {
                        targetCtx.beginPath();
                        targetCtx.arc(-size/3 + i*size/3, -size/3 + j*size/3, size/12, 0, Math.PI*2);
                        targetCtx.fill();
                    }
                }
            } else if (type === 'swiss_behemoth') {
                targetCtx.fillStyle = '#F7DC6F'; // Light yellow
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeRect(-size/2, -size/2, size, size);
                targetCtx.fillStyle = '#D4AC0D';
                for(let i=0; i<5; i++) {
                    targetCtx.beginPath();
                    targetCtx.arc((Math.random()-0.5)*size/2, (Math.random()-0.5)*size/2, size/8, 0, Math.PI*2);
                    targetCtx.fill();
                }
            } else if (type === 'gruyere_golem') {
                targetCtx.fillStyle = '#D2B48C';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeRect(-size/2, -size/2, size, size);
                targetCtx.fillStyle = '#8B4513';
                targetCtx.fillRect(-size/4, -size/4, size/2, size/2);
            } else if (type === 'limburger_lazer') {
                targetCtx.fillStyle = '#3CB371';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 2, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.stroke();
                targetCtx.fillStyle = 'lime';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 4, 0, Math.PI * 2);
                targetCtx.fill();
            } else if (type === 'edam_eradicator') {
                targetCtx.fillStyle = '#FF4500';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.stroke();
                targetCtx.fillStyle = 'yellow';
                targetCtx.beginPath();
                targetCtx.moveTo(0, -size/2);
                targetCtx.lineTo(size/4, 0);
                targetCtx.lineTo(-size/4, 0);
                targetCtx.closePath();
                targetCtx.fill();
            } else if (type === 'morbier_maelstrom') {
                targetCtx.fillStyle = '#483D8B';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 2, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.stroke();
                targetCtx.fillStyle = '#E6E6FA';
                targetCtx.save();
                targetCtx.globalAlpha = 0.5;
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/3, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.restore();
            } else if (type === 'burrata_bomber') {
                targetCtx.fillStyle = '#F5F5DC';
                targetCtx.beginPath();
                targetCtx.ellipse(0, 0, size/1.5, size/2, 0, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.stroke();
                targetCtx.fillStyle = 'red';
                targetCtx.fillRect(-size/3, size/2 - 5, size*2/3, 5);
            } else if (type === 'stilton_singularity' || type === 'swiss_singularity') {
                targetCtx.fillStyle = type === 'stilton_singularity' ? '#000080' : 'black';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeRect(-size/2, -size/2, size, size);
                const grad = targetCtx.createRadialGradient(0, 0, 1, 0, 0, size/3);
                grad.addColorStop(0, 'black');
                grad.addColorStop(1, 'purple');
                targetCtx.fillStyle = grad;
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/3, 0, Math.PI*2);
                targetCtx.fill();
            } else if (type === 'wensleydale_whirlwind') {
                 targetCtx.fillStyle = '#F5F5F5';
                 targetCtx.fillRect(-size/2, -size/2, size, size);
                 targetCtx.strokeStyle = '#999';
                 for(let i=0; i<3; i++) {
                     targetCtx.beginPath();
                     targetCtx.arc(0, 0, size/2 - i*5, 0, Math.PI*2);
                     targetCtx.stroke();
                 }
            } else if (type === 'jarlsberg_juggernaut') {
                targetCtx.fillStyle = '#F0E68C';
                targetCtx.beginPath();
                targetCtx.arc(0,0,size/2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.stroke();
                targetCtx.fillStyle = '#DAA520';
                targetCtx.beginPath();
                targetCtx.arc(0,0,size/3, 0, Math.PI*2);
                targetCtx.fill();
            } else if (type === 'feta_fleet') {
                 targetCtx.fillStyle = '#F8F9F9';
                 targetCtx.fillRect(-size/2, -size/2, size, size);
                 targetCtx.fillStyle = '#3498DB';
                 targetCtx.beginPath();
                 targetCtx.moveTo(0, -size/2); targetCtx.lineTo(size/2, size/2); targetCtx.lineTo(-size/2, size/2);
                 targetCtx.closePath();
                 targetCtx.fill();
            } else if (type === 'asiago_annihilator') {
                 targetCtx.fillStyle = '#17202A';
                 targetCtx.fillRect(-size/2, -size/2, size, size);
                 targetCtx.fillStyle = 'red';
                 targetCtx.beginPath();
                 targetCtx.arc(0,0,size/3, 0, Math.PI*2);
                 targetCtx.fill();
            } else if (type === 'roquefort_rain') {
                targetCtx.fillStyle = '#2980B9';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.fillStyle = '#D6EAF8';
                 for(let i=0; i<3; i++) {
                     targetCtx.beginPath();
                     targetCtx.arc((Math.random()-0.5)*size/2, (Math.random()-0.5)*size/2, size/8, 0, Math.PI*2);
                     targetCtx.fill();
                 }
            } else if (type === 'mascarpone_matrix') {
                targetCtx.fillStyle = '#FEF9E7';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeStyle = '#F7DC6F';
                targetCtx.lineWidth = 4;
                targetCtx.strokeRect(-size/2, -size/2, size, size);
            } else if (type === 'halloumi_hellfire' || type === 'halloumi_hellstorm') {
                targetCtx.fillStyle = '#C0392B';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.fillStyle = 'orange';
                targetCtx.beginPath();
                targetCtx.moveTo(-size/4, -size/2); targetCtx.lineTo(size/4, -size/2); targetCtx.lineTo(0, -size);
                targetCtx.closePath();
                targetCtx.fill();
            } else if (type === 'cotija_citadel') {
                 targetCtx.fillStyle = 'white';
                 targetCtx.fillRect(-size/2, -size/2, size, size);
                 targetCtx.strokeRect(-size/2, -size/2, size, size);
                 targetCtx.fillStyle = 'gold';
                 targetCtx.font = `bold ${size}px sans-serif`;
                 targetCtx.textAlign = 'center';
                 targetCtx.textBaseline = 'middle';
                 targetCtx.fillText('★', 0, 2);
            } else if (type === 'velveeta_volcano') {
                targetCtx.fillStyle = '#E67E22';
                targetCtx.beginPath();
                targetCtx.moveTo(-size, size/2); targetCtx.lineTo(size, size/2); targetCtx.lineTo(0, -size);
                targetCtx.closePath();
                targetCtx.fill();
            } else if (type === 'paneer_pulsar') {
                targetCtx.fillStyle = '#F4F6F7';
                targetCtx.beginPath();
                targetCtx.arc(0,0,size/2,0,Math.PI*2);
                targetCtx.fill();
                targetCtx.strokeStyle = 'cyan';
                targetCtx.lineWidth = 3;
                targetCtx.beginPath();
                targetCtx.arc(0,0,size/3,0,Math.PI*2);
                targetCtx.stroke();
            } else if (type === 'gjetost_giant') {
                targetCtx.fillStyle = '#935116';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.fillStyle = 'black';
                targetCtx.fillRect(-size/4, -size/4, size/2, size/2);
            } else if (type === 'bocconcini_barrage') {
                targetCtx.fillStyle = '#FBFCFC';
                targetCtx.beginPath();
                targetCtx.arc(0,0,size/2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.stroke();
            } else if (type === 'teleggio_tesseract') {
                targetCtx.fillStyle = '#F5B041';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeStyle = 'black';
                targetCtx.lineWidth = 3;
                targetCtx.strokeRect(-size/3, -size/3, size*2/3, size*2/3);
            } else if (type === 'raclette_reactor') {
                 targetCtx.fillStyle = '#424949';
                 targetCtx.beginPath();
                 targetCtx.arc(0,0,size/2,0,Math.PI*2);
                 targetCtx.fill();
                 targetCtx.fillStyle = 'yellow';
                 targetCtx.beginPath();
                 targetCtx.arc(0,0,size/4,0,Math.PI*2);
                 targetCtx.fill();
            } else if (type === 'provolone_pantheon') {
                targetCtx.fillStyle = '#FDEBD0';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeRect(-size/2, -size/2, size, size);
                 targetCtx.fillStyle = '#D35400';
                 targetCtx.font = `bold ${size/2}px sans-serif`;
                 targetCtx.textAlign = 'center';
                 targetCtx.textBaseline = 'middle';
                 targetCtx.fillText('P', 0, 2);
            } else if (type === 'queso_quattro') {
                targetCtx.fillStyle = '#F1C40F';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.fillStyle = 'red';
                targetCtx.fillRect(-size/2,-size/2,size/2,size/2);
                targetCtx.fillStyle = 'blue';
                targetCtx.fillRect(0,0,size/2,size/2);
                 targetCtx.fillStyle = 'green';
                targetCtx.fillRect(0,-size/2,size/2,size/2);
            } else if (type === 'epoisses_erupter') {
                targetCtx.fillStyle = '#D35400';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 2, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.fillStyle = '#F5CBA7';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size / 3, 0, Math.PI * 2);
                targetCtx.fill();
            } else if (type === 'gorgonzola_grid') {
                targetCtx.fillStyle = '#3498DB';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeStyle = '#2980B9';
                targetCtx.lineWidth = 2;
                targetCtx.beginPath();
                targetCtx.moveTo(-size/2, 0); targetCtx.lineTo(size/2, 0);
                targetCtx.moveTo(0, -size/2); targetCtx.lineTo(0, size/2);
                targetCtx.stroke();
            } else if (type === 'stinking_bishops_smite') {
                targetCtx.fillStyle = '#F4D03F';
                targetCtx.beginPath();
                targetCtx.moveTo(0, -size/1.2);
                targetCtx.lineTo(size/3, size/1.2);
                targetCtx.lineTo(-size/3, size/1.2);
                targetCtx.closePath();
                targetCtx.fill();
            } else if (type === 'valdeon_vortex') {
                targetCtx.fillStyle = '#8E44AD';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.strokeStyle = '#D2B4DE';
                targetCtx.lineWidth = 3;
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/3, Math.PI/4, Math.PI*3/4);
                targetCtx.stroke();
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/3, Math.PI*5/4, Math.PI*7/4);
                targetCtx.stroke();
            } else if (type === 'casu_marzus_call') {
                targetCtx.fillStyle = '#F5CBA7';
                targetCtx.beginPath();
                targetCtx.arc(0,0, size/2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.fillStyle = '#943126';
                 for(let i=0; i<3; i++) {
                     targetCtx.beginPath();
                     targetCtx.arc((Math.random()-0.5)*size/2, (Math.random()-0.5)*size/2, size/10, 0, Math.PI*2);
                     targetCtx.fill();
                 }
            } else if (type === 'pule_pummeler') {
                targetCtx.fillStyle = '#FDFEFE';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeStyle = '#F1C40F';
                targetCtx.lineWidth = 4;
                targetCtx.strokeRect(-size/2, -size/2, size, size);
                targetCtx.fillStyle = '#B08D57';
                targetCtx.fillRect(-size/4, -size/4, size/2, size/2);
            } else if (type === 'pont-leveque_portal') {
                targetCtx.fillStyle = '#FAD7A0';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                const grad = targetCtx.createRadialGradient(0, 0, size/10, 0, 0, size/2.5);
                grad.addColorStop(0, '#A569BD');
                grad.addColorStop(1, '#5B2C6F');
                targetCtx.fillStyle = grad;
                targetCtx.beginPath();
                targetCtx.arc(0,0, size/2.5, 0, Math.PI*2);
                targetCtx.fill();
            } else if (type === 'stilton_supernova') {
                targetCtx.fillStyle = '#2980B9';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.fillStyle = 'white';
                 for (let i = 0; i < 8; i++) {
                     const angle = i * Math.PI / 4;
                     targetCtx.beginPath();
                     targetCtx.moveTo(0,0);
                     targetCtx.lineTo(Math.cos(angle) * size/2, Math.sin(angle) * size/2);
                     targetCtx.lineTo(Math.cos(angle + 0.1) * size/3, Math.sin(angle + 0.1) * size/3);
                     targetCtx.closePath();
                     targetCtx.fill();
                 }
            } else if (type === 'roquefort_rift') {
                targetCtx.fillStyle = 'black';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.fillStyle = '#4A235A';
                targetCtx.fillRect(-size/2, -4, size, 8);
                targetCtx.strokeStyle = '#D7BDE2';
                targetCtx.lineWidth = 2;
                targetCtx.beginPath();
                targetCtx.moveTo(-size/2, 0);
                targetCtx.bezierCurveTo(-size/4, -size/4, size/4, size/4, size/2, 0);
                targetCtx.stroke();
            } else if (type === 'gouda_god-hand') {
                targetCtx.fillStyle = '#F39C12';
                targetCtx.fillRect(-size/2, size/4, size, size/2);
                targetCtx.beginPath();
                for(let i=0; i<5; i++) {
                    targetCtx.roundRect(-size/2 + i*(size/5) + 2, -size/2, size/6, size/1.5, [5]);
                }
                targetCtx.fill();
            } else if (type === 'cheddar_cataclysm') {
                targetCtx.fillStyle = '#E67E22';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeStyle = '#A04000';
                targetCtx.lineWidth = 3;
                targetCtx.beginPath();
                targetCtx.moveTo(-size/2, -size/4);
                targetCtx.lineTo(0, -size/4);
                targetCtx.lineTo(size/4, size/2);
                targetCtx.moveTo(size/8, -size/2);
                targetCtx.lineTo(size/8, size/8);
                targetCtx.lineTo(size/2, size/8);
                targetCtx.stroke();
            } else if (type === 'brie_black_hole') {
                targetCtx.fillStyle = 'black';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.strokeStyle = '#C39BD3';
                targetCtx.lineWidth = 3;
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/2.2, 0, Math.PI*2);
                targetCtx.stroke();
            } else if (type === 'mozzarella_moonfall') {
                targetCtx.fillStyle = '#F2F3F4';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.fillStyle = '#BCC6CC';
                targetCtx.beginPath();
                targetCtx.arc(size/4, -size/6, size/8, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.beginPath();
                targetCtx.arc(-size/4, size/5, size/6, 0, Math.PI*2);
                targetCtx.fill();
            } else if (type === 'provolone_pandemic') {
                targetCtx.fillStyle = '#27AE60';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.strokeStyle = '#1E8449';
                targetCtx.lineWidth = 4;
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/3, 0, Math.PI);
                targetCtx.stroke();
                targetCtx.beginPath();
                targetCtx.arc(-size/4, 0, size/8, 0, Math.PI);
                targetCtx.stroke();
                 targetCtx.beginPath();
                targetCtx.arc(size/4, 0, size/8, 0, Math.PI);
                targetCtx.stroke();
            } else if (type === 'feta_freeze-frame') {
                targetCtx.fillStyle = '#5DADE2';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeStyle = 'white';
                targetCtx.lineWidth = 3;
                for (let i = 0; i < 6; i++) {
                    const angle = i * Math.PI / 3;
                    targetCtx.beginPath();
                    targetCtx.moveTo(0,0);
                    targetCtx.lineTo(Math.cos(angle) * size/2, Math.sin(angle) * size/2);
                    targetCtx.stroke();
                }
            } else if (type === 'parmesan_paradox') {
                targetCtx.fillStyle = '#F4D03F';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeStyle = 'black';
                targetCtx.lineWidth = 2;
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/2.5, 0, Math.PI*2);
                targetCtx.stroke();
                targetCtx.beginPath();
                targetCtx.moveTo(0,0);
                targetCtx.lineTo(0, -size/3);
                targetCtx.moveTo(0,0);
                targetCtx.lineTo(size/4, 0);
                targetCtx.stroke();
            } else if (type === 'the_cheesus_christ') {
                targetCtx.fillStyle = 'white';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeStyle = 'gold';
                targetCtx.lineWidth = 4;
                targetCtx.strokeRect(-size/2, -size/2, size, size);
                targetCtx.font = `bold ${size/2}px Inter`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                targetCtx.fillStyle = 'gold';
                targetCtx.fillText('JC', 0, 2);
            }
            else {
                // Default fallback design for any towers not explicitly defined
                targetCtx.fillStyle = '#cccccc';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeRect(-size/2, -size/2, size, size);
                targetCtx.fillStyle = 'black';
                targetCtx.font = 'bold 12px Inter';
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                targetCtx.fillText('?', 0, 0);
            }
            // --- END TOWER REDESIGNS ---

            targetCtx.restore();

            if (tower.shield > 0) { 
                targetCtx.strokeStyle = 'cyan'; 
                targetCtx.lineWidth = 3; 
                targetCtx.beginPath(); 
                targetCtx.arc(x, y, size/2 + 5, 0, Math.PI*2); 
                targetCtx.stroke(); 
            }
            targetCtx.globalAlpha = 1.0;
        }

        function drawEnemy(enemy, targetCtx = ctx) { 
            const { x, y, size, type, visual } = enemy; 
            targetCtx.save();
            targetCtx.translate(x, y);

            if (enemy.isFrozen) { targetCtx.globalAlpha = 0.7; }
            if (enemy.phasing) { targetCtx.globalAlpha = 0.3; }

            // --- ENEMY REDESIGNS ---
            if (type === 'normal') {
                const grad = targetCtx.createLinearGradient(-size, -size, size, size);
                grad.addColorStop(0, '#F9E79F');
                grad.addColorStop(1, '#F1C40F');
                targetCtx.fillStyle = grad;
                targetCtx.fillRect(-size/2, -size/2, size, size);
            } else if (type === 'scout') {
                targetCtx.fillStyle = '#F39C12';
                targetCtx.beginPath();
                targetCtx.moveTo(0, -size);
                targetCtx.lineTo(size/2, size/2);
                targetCtx.lineTo(-size/2, size/2);
                targetCtx.closePath();
                targetCtx.fill();
            } else if (type === 'bruiser') {
                targetCtx.fillStyle = '#AF601A';
                targetCtx.fillRect(-size, -size, size*2, size*2);
            } else if (type === 'popper') {
                targetCtx.fillStyle = '#2ECC71';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.fillStyle = 'lime';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size/2, 0, Math.PI*2);
                targetCtx.fill();
            } else if (type === 'moldy') {
                targetCtx.fillStyle = '#556B2F';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size, 0, Math.PI*2);
                targetCtx.fill();
                for(let i=0; i<5; i++) { 
                    targetCtx.fillStyle = '#9ACD32'; 
                    targetCtx.beginPath(); 
                    targetCtx.arc((Math.random()-0.5)*size, (Math.random()-0.5)*size, size/4, 0, Math.PI*2); 
                    targetCtx.fill(); 
                }
            } else if (type === 'pbj') {
                // Bread crust color
                targetCtx.fillStyle = '#A0522D';
                targetCtx.fillRect(-size, -size/2, size*2, size);
                // Peanut butter smear
                targetCtx.fillStyle = '#D2B48C';
                targetCtx.beginPath();
                targetCtx.arc(-size/2, 0, size/3, 0, Math.PI*2);
                targetCtx.fill();
                // Jelly smear
                targetCtx.fillStyle = '#8E44AD';
                targetCtx.beginPath();
                targetCtx.arc(size/2, 0, size/3, 0, Math.PI*2);
                targetCtx.fill();
            } else if (type === 'goliath') {
                targetCtx.fillStyle = '#5C4033';
                targetCtx.fillRect(-size * 1.5, -size * 1.5, size * 3, size * 3);
                targetCtx.fillStyle = '#856047';
                targetCtx.fillRect(-size, -size, size*2, size*2);
            } else if (type === 'medic') {
                targetCtx.fillStyle = 'white';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.strokeStyle = 'red';
                targetCtx.lineWidth = 3;
                targetCtx.beginPath();
                targetCtx.moveTo(-size/2, 0);
                targetCtx.lineTo(size/2, 0);
                targetCtx.moveTo(0, -size/2);
                targetCtx.lineTo(0, size/2);
                targetCtx.stroke();
            } else if (type === 'speeder') {
                targetCtx.fillStyle = 'yellow';
                targetCtx.beginPath();
                targetCtx.moveTo(0, -size*1.5);
                targetCtx.lineTo(size/2, size*1.5);
                targetCtx.lineTo(0, size);
                targetCtx.lineTo(-size/2, size*1.5);
                targetCtx.closePath();
                targetCtx.fill();
            } else if (type === 'breeder') {
                targetCtx.fillStyle = 'purple';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.fillStyle = 'grey';
                targetCtx.beginPath();
                targetCtx.arc(-size/3, 0, size/3, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.beginPath();
                targetCtx.arc(size/3, 0, size/3, 0, Math.PI * 2);
                targetCtx.fill();
            } else if (type === 'saboteur') {
                targetCtx.fillStyle = 'black';
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.strokeStyle = 'red';
                targetCtx.lineWidth = 3;
                targetCtx.beginPath();
                targetCtx.moveTo(-size/2, -size/2);
                targetCtx.lineTo(size/2, size/2);
                targetCtx.moveTo(size/2, -size/2);
                targetCtx.lineTo(-size/2, size/2);
                targetCtx.stroke();
            } else if (type === 'boss') {
                // Bread
                targetCtx.fillStyle = '#D2691E';
                targetCtx.fillRect(-size*2, -size*2, size*4, size*4);
                // Cheese
                targetCtx.fillStyle = '#FFD700';
                targetCtx.fillRect(-size*1.8, -size*1.8, size*3.6, size*3.6);
                // Eyes
                targetCtx.fillStyle = 'red';
                targetCtx.beginPath();
                targetCtx.arc(-size, -size/2, size/3, 0, Math.PI*2);
                targetCtx.arc(size, -size/2, size/3, 0, Math.PI*2);
                targetCtx.fill();
            } else if (type === 'burnt_beast') {
                targetCtx.fillStyle = '#3E2723'; // Dark, burnt brown
                targetCtx.fillRect(-size*2, -size*2, size*4, size*4);
                targetCtx.strokeStyle = '#FF7043'; // Lava cracks
                targetCtx.lineWidth = 3;
                for (let i = 0; i < 5; i++) {
                    targetCtx.beginPath();
                    targetCtx.moveTo((Math.random() - 0.5) * size * 4, (Math.random() - 0.5) * size * 4);
                    targetCtx.lineTo((Math.random() - 0.5) * size * 4, (Math.random() - 0.5) * size * 4);
                    targetCtx.stroke();
                }
            } else if (type === 'moldy_monarch') {
                targetCtx.fillStyle = '#4CAF50'; // Main green
                targetCtx.beginPath();
                targetCtx.arc(0, 0, size * 2, 0, Math.PI*2);
                targetCtx.fill();
                for (let i = 0; i < 20; i++) {
                    targetCtx.fillStyle = '#388E3C'; // Darker spots
                    targetCtx.beginPath();
                    targetCtx.arc((Math.random() - 0.5) * size * 3, (Math.random() - 0.5) * size * 3, size / 3, 0, Math.PI*2);
                    targetCtx.fill();
                }
            } else if (type === 'ghost_pepper') {
                targetCtx.fillStyle = '#FF4500';
                targetCtx.beginPath();
                targetCtx.moveTo(0, -size*1.2);
                targetCtx.bezierCurveTo(size, -size, size, size, 0, size*1.2);
                targetCtx.bezierCurveTo(-size, size, -size, -size, 0, -size*1.2);
                targetCtx.fill();
            } else if (type === 'teleporter') {
                targetCtx.fillStyle = '#FDFEFE';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.fillStyle = 'black';
                targetCtx.fillRect(-size/3, -size/3, size/3, size/3);
                targetCtx.fillRect(0, 0, size/3, size/3);
            } else if (type === 'healer') {
                targetCtx.fillStyle = '#F8F9F9';
                targetCtx.beginPath();
                targetCtx.arc(0,0,size*1.2, 0, Math.PI*2);
                targetCtx.fill();
                targetCtx.fillStyle = '#ABEBC6';
                targetCtx.font = `bold ${size}px sans-serif`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                targetCtx.fillText('+', 0, 2);
            } else if (type === 'thief') {
                targetCtx.fillStyle = '#566573';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.fillStyle = '#F1C40F';
                targetCtx.font = `bold ${size}px sans-serif`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                targetCtx.fillText('$', 0, 2);
            } else if (type === 'mimic') {
                targetCtx.fillStyle = '#FAD7A0'; // Looks like normal crumb but slightly off-color
                targetCtx.fillRect(-size/2, -size/2, size, size);
            } else if (type === 'splitter') {
                 targetCtx.fillStyle = '#D5D8DC';
                targetCtx.beginPath();
                targetCtx.arc(0,0,size,0,Math.PI*2);
                targetCtx.fill();
            } else if (type === 'phasing') {
                 targetCtx.fillStyle = '#D6EAF8';
                 targetCtx.fillRect(-size, -size, size*2, size*2);
            } else if (type === 'general') {
                targetCtx.fillStyle = '#D4AC0D';
                targetCtx.fillRect(-size, -size, size*2, size*2);
                targetCtx.fillStyle = 'white';
                targetCtx.font = `bold ${size*1.5}px sans-serif`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                targetCtx.fillText('★', 0, 2);
            } else if (type === 'kamikaze') {
                targetCtx.fillStyle = '#E74C3C';
                targetCtx.beginPath();
                targetCtx.arc(0,0,size,0,Math.PI*2);
                targetCtx.fill();
                targetCtx.fillStyle = 'yellow';
                targetCtx.beginPath();
                targetCtx.moveTo(0,-size);
                targetCtx.lineTo(size*0.5, 0);
                targetCtx.lineTo(0, size*0.5);
                targetCtx.lineTo(-size*0.5, 0);
                targetCtx.closePath();
                targetCtx.fill();
            } else if (type === 'frost_crumb') {
                targetCtx.fillStyle = '#AED6F1';
                targetCtx.fillRect(-size/2, -size/2, size, size);
                targetCtx.strokeStyle = 'white';
                targetCtx.lineWidth = 2;
                targetCtx.strokeRect(-size/2, -size/2, size, size);
            }


            // --- END ENEMY REDESIGNS ---

            targetCtx.restore();

            if (enemy.isBurning) { ctx.fillStyle = `rgba(255, 100, 0, ${Math.random() * 0.5 + 0.5})`; ctx.beginPath(); ctx.arc(x, y, size * 1.2, 0, Math.PI * 2); ctx.fill(); } 
            if (enemy.isShocked) { ctx.fillStyle = `rgba(255, 255, 0, ${Math.random() * 0.5 + 0.5})`; ctx.beginPath(); ctx.arc(x, y, size * 1.2, 0, Math.PI * 2); ctx.fill(); }
            if (enemy.isFrozen) { ctx.fillStyle = 'rgba(0, 255, 255, 0.5)'; ctx.fillRect(x - size * 1.2, y - size * 1.2, size * 2.4, size * 2.4); ctx.globalAlpha = 1.0; }
        }

        function drawFriendlyUnit(unit) {
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(unit.x, unit.y, unit.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawProjectile(p) { if (p.type === 'lazar' || p.type === 'continuous_lazar') { ctx.strokeStyle = p.color; ctx.lineWidth = p.duration / 2; ctx.beginPath(); ctx.moveTo(p.originX, p.originY); ctx.lineTo(p.x, p.y); ctx.stroke(); } else if (p.type === 'bomb' || p.type === 'rocket' || p.type === 'blimp_bomb' || p.type === 'carpet_bomb' || p.type === 'shock_blast') { if (p.detonated) { ctx.fillStyle = p.blastColor || `rgba(255, 165, 0, ${p.blastDuration / 15})`; ctx.beginPath(); ctx.arc(p.x, p.y, p.blastRadius, 0, Math.PI * 2); ctx.fill(); } else { ctx.fillStyle = p.type === 'rocket' ? '#C0C0C0' : '#2F4F4F'; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); } } else if (p.type === 'brie_rocket') { ctx.fillStyle = '#DEB887'; ctx.beginPath(); ctx.ellipse(p.x, p.y, p.size, p.size/1.5, 0, 0, Math.PI*2); ctx.fill(); } else { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); } }

        function drawDecorations() { 
            ctx.globalAlpha = 0.8;
            decorations.forEach(d => {
                if (d.type === 'tree') { 
                    ctx.fillStyle = '#8B4513'; // Trunk
                    ctx.fillRect(d.x - 5, d.y, 10, 20); 
                    ctx.fillStyle = '#228B22'; // Leaves
                    ctx.beginPath(); 
                    ctx.arc(d.x, d.y, 20, 0, Math.PI * 2); 
                    ctx.fill(); 
                } else if (d.type === 'flowers') { 
                    for(let i=0; i<5; i++) { 
                        ctx.fillStyle = d.colors[i]; 
                        ctx.beginPath(); 
                        ctx.arc(d.x + d.pos[i].x, d.y + d.pos[i].y, 3, 0, Math.PI*2); 
                        ctx.fill(); 
                    } 
                } else if (d.type === 'mushrooms') { 
                    for(let i=0; i<3; i++) { 
                        ctx.fillStyle = '#A0A0A0'; // Stem
                        ctx.fillRect(d.x + d.pos[i].x - 2, d.y + d.pos[i].y, 4, 10); 
                        ctx.fillStyle = '#FF6347'; // Cap
                        ctx.beginPath(); 
                        ctx.arc(d.x + d.pos[i].x, d.y + d.pos[i].y, 6, Math.PI, 0); 
                        ctx.fill(); 
                    } 
                } 
            }); 
            ctx.globalAlpha = 1; 
        }
        
        function drawSpecialEffects() { for (let i = specialEffects.length - 1; i >= 0; i--) { const effect = specialEffects[i]; if (effect.type === 'gas_cloud' || effect.type === 'large_gas_cloud') { ctx.fillStyle = `rgba(107, 142, 35, ${0.4 * (effect.duration / effect.maxDuration)})`; ctx.beginPath(); ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI*2); ctx.fill(); } else if (effect.type === 'prism_aura') { ctx.strokeStyle = `rgba(218, 112, 214, ${0.5 * (effect.duration / effect.maxDuration)})`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI*2); ctx.stroke(); } else if (effect.type === 'fondue_wave') { ctx.fillStyle = `rgba(255, 140, 0, ${0.8 * (effect.duration / effect.maxDuration)})`; ctx.beginPath(); ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI*2); ctx.fill(); } else if (effect.type === 'spore_cloud') { ctx.fillStyle = `rgba(128, 128, 0, ${0.6 * (effect.duration / effect.maxDuration)})`; ctx.beginPath(); ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI*2); ctx.fill(); } else if (effect.type === 'popper_explosion') { ctx.fillStyle = `rgba(255, 69, 0, ${0.8 * (effect.duration / effect.maxDuration)})`; ctx.beginPath(); ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI*2); ctx.fill(); } else if (effect.type === 'hailstorm') { ctx.fillStyle = `rgba(173, 216, 230, ${0.5 * (effect.duration / effect.maxDuration)})`; ctx.beginPath(); ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI*2); ctx.fill(); } else if (effect.type === 'vortex' || effect.type === 'super_vortex') { ctx.strokeStyle = `rgba(72, 61, 139, ${0.6 * (effect.duration / effect.maxDuration)})`; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(effect.x, effect.y, effect.radius * (1 - (effect.duration / effect.maxDuration)), 0, Math.PI * 2); ctx.stroke(); } else if (effect.type === 'fire_trail') { ctx.fillStyle = `rgba(255, 69, 0, ${0.5 * (effect.duration / effect.maxDuration)})`; ctx.beginPath(); ctx.arc(effect.x, effect.y, 5, 0, Math.PI * 2); ctx.fill(); } else if (effect.type === 'heal_aura') { ctx.fillStyle = `rgba(173, 255, 47, ${0.3 * (effect.duration / effect.maxDuration)})`; ctx.beginPath(); ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2); ctx.fill(); } else if (effect.type === 'speed_aura') { ctx.strokeStyle = `rgba(255, 255, 0, ${0.4 * (effect.duration / effect.maxDuration)})`; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2); ctx.stroke(); } else if (effect.type === 'earthquake') { ctx.strokeStyle = `rgba(139, 69, 19, ${0.8 * (effect.duration / effect.maxDuration)})`; ctx.lineWidth = effect.radius * 0.1; ctx.beginPath(); ctx.arc(effect.x, effect.y, effect.radius * (1 - (effect.duration / effect.maxDuration)), 0, Math.PI * 2); ctx.stroke(); } else if (effect.type === 'reactor_blast') { ctx.fillStyle = `rgba(255, 255, 0, ${0.9 * (effect.duration / effect.maxDuration)})`; ctx.beginPath(); ctx.arc(canvasWidth/2, canvasHeight/2, effect.radius, 0, Math.PI*2); ctx.fill(); } effect.duration--; if (effect.duration <= 0) specialEffects.splice(i, 1); } }

        function drawBase() { const endPoint = scaledPath[scaledPath.length - 1]; ctx.fillStyle = '#CD853F'; ctx.fillRect(endPoint.x, endPoint.y - 50, 50, 100); ctx.fillStyle = '#8B4513'; ctx.beginPath(); ctx.moveTo(endPoint.x, endPoint.y - 50); ctx.lineTo(endPoint.x + 50, endPoint.y - 50); ctx.lineTo(endPoint.x + 25, endPoint.y - 80); ctx.closePath(); ctx.fill(); const barWidth = 100; ctx.fillStyle = '#DC2626'; ctx.fillRect(endPoint.x - 25, endPoint.y - 100, barWidth, 10); ctx.fillStyle = '#22C55E'; ctx.fillRect(endPoint.x - 25, endPoint.y - 100, barWidth * (baseHealth / maxBaseHealth), 10); }

        function drawFloatingTexts() { ctx.textAlign = 'center'; for (let i = floatingTexts.length - 1; i >= 0; i--) { const text = floatingTexts[i]; ctx.fillStyle = `rgba(${text.color}, ${text.duration / 60})`; ctx.font = `bold ${text.size}px Inter`; ctx.fillText(text.content, text.x, text.y); text.y -= 0.5; text.duration--; if (text.duration <= 0) floatingTexts.splice(i, 1); } }
        
        function drawUpgradeMenu() {
            if (!selectedTower) return;
            const { x, y, size, upgradeCost, level, type, totalSpent } = selectedTower;
            const menuWidth = 120;
            let menuHeight = 70; // Base height for upgrade + sell
            if (type === 'fondue') menuHeight += 35; // Extra space for launch button

            const menuX = x + size/2 + 10;
            const menuY = y - menuHeight / 2;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.strokeStyle = '#6B4F32'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.roundRect(menuX, menuY, menuWidth, menuHeight, [10]); ctx.fill(); ctx.stroke();
            
            // Upgrade section
            ctx.fillStyle = 'black'; ctx.font = 'bold 12px Inter'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
            let upgradeText = TOWER_DATA[type].upgrade.charAt(0).toUpperCase() + TOWER_DATA[type].upgrade.slice(1);
            if (type === 'gold' || TOWER_DATA[type].upgrade === 'cash') {
                upgradeText = 'Cash Prod.';
            }
            ctx.fillText(`Lvl ${level} ${upgradeText}`, menuX + 5, menuY + 10);
            ctx.fillText(`Cost: ${upgradeCost}`, menuX + 5, menuY + 28);
            
            const btnX = menuX + menuWidth - 40; const btnY = menuY + 5;
            ctx.fillStyle = gold >= upgradeCost ? '#fcd34d' : '#9ca3af';
            ctx.beginPath(); ctx.roundRect(btnX, btnY, 35, 30, [8]); ctx.fill(); ctx.stroke();
            ctx.fillStyle = 'black'; ctx.font = 'bold 18px Inter'; ctx.textAlign = 'center';
            ctx.fillText('+', btnX + 17.5, btnY + 16);

            // Sell section
            const sellBtnY = menuY + 40;
            ctx.fillStyle = '#fca5a5';
            ctx.beginPath(); ctx.roundRect(menuX + 5, sellBtnY, menuWidth - 10, 25, [8]); ctx.fill(); ctx.stroke();
            ctx.fillStyle = 'black'; ctx.font = 'bold 12px Inter'; ctx.textAlign = 'center';
            ctx.fillText(`Sell for ${Math.floor(totalSpent / 2)}`, menuX + menuWidth / 2, sellBtnY + 13);

            // Special button for Fondue
            if (type === 'fondue') {
                const specialBtnY = menuY + 75;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath(); ctx.roundRect(menuX, specialBtnY, menuWidth, 30, [8]); ctx.fill(); ctx.stroke();
                ctx.fillStyle = selectedTower.fireCooldown > 0 ? '#9ca3af' : '#ef4444';
                ctx.font = 'bold 14px Inter'; ctx.textAlign = 'center';
                ctx.fillText(selectedTower.fireCooldown > 0 ? `CD: ${Math.ceil(selectedTower.fireCooldown/60)}` : 'LAUNCH', menuX + 60, specialBtnY + 15);
            }
        }

        // --- Game Logic ---
        function init(difficulty = 'normal') {
            currentDifficulty = difficulty;
            
            setupTowerData(); // Reset tower data to original values
            if (difficulty === 'normal') {
                difficultyModifier = { health: 1, speed: 1 };
                backgroundColor = '#2E8B57';
            } else if (difficulty === 'hard') {
                difficultyModifier = { health: 1.5, speed: 1.2 };
                backgroundColor = '#2E8B57'; // Base for tint
            } else if (difficulty === 'hardcore') {
                difficultyModifier = { health: 3, speed: 3 };
                backgroundColor = '#8B0000'; // Full red for hardcore
            }


            gold = 100;
            maxBaseHealth = 1500;
            baseHealth = maxBaseHealth;

            if (difficulty === 'hardcore') {
                gold = 550;
                maxBaseHealth = 10000;
                baseHealth = maxBaseHealth;
                // Adjust tower costs for hardcore mode
                const expensiveTowerTypes = Object.keys(TOWER_DATA).slice(Object.keys(TOWER_DATA).indexOf('bomber'));
                 expensiveTowerTypes.forEach(type => {
                     if (TOWER_DATA[type]) {
                         TOWER_DATA[type].cost = Math.round(originalTowerData[type].cost * 1.5);
                     }
                });
            }

            wave = 0; 
            enemyStrengthModifier = 1.0;
            enemySpeedModifier = 1.0;
            isBaseInvincible = false;
            invincibleBaseToggle.checked = false;
            enemies = []; towers = []; projectiles = []; decorations = []; floatingTexts = []; specialEffects = []; friendlyUnits = [];
            gameOver = false; waveInProgress = false; bossWave = false; bossSpawned = false; demonModeActive = false; hellModeActive = false;
            selectedTowerType = null; selectedTower = null;
            
            if (gameInterval) clearInterval(gameInterval); if (timerInterval) clearInterval(timerInterval);
            resizeCanvas(); 

            if (difficulty === 'hard') {
                const bgCtx = backgroundCanvas.getContext('2d');
                bgCtx.fillStyle = 'rgba(255, 0, 0, 0.2)'; // Add red tint
                bgCtx.fillRect(0, 0, canvasWidth, canvasHeight);
            }
            
            createTowerButtons(); 
            populateIndex();
            updateUI();
            setGameSpeed(1); // Reset to normal speed
            if (isPaused) togglePause(); // Unpause if paused
            gameInterval = setInterval(gameLoop, 1000 / 60);
            startWaveTimer();
            gameOverModal.classList.add('opacity-0', 'scale-90');
            setTimeout(() => gameOverModal.classList.add('hidden'), 300);
            adminPanel.classList.add('hidden');
            adminPanelButton.classList.add('hidden');
            preGameOverlay.style.display = 'none';
        }

        function resizeCanvas() { 
            canvasWidth = parentDiv.clientWidth; 
            canvasHeight = parentDiv.clientHeight; 
            canvas.width = canvasWidth; 
            canvas.height = canvasHeight; 
            scaledPath = path.map(p => ({ x: p.x * canvasWidth, y: p.y * canvasHeight })); 
            createGreenBackground();
            generateDecorations();
        }

        function createGreenBackground() {
            backgroundCanvas = document.createElement('canvas');
            backgroundCanvas.width = canvasWidth;
            backgroundCanvas.height = canvasHeight;
            const bgCtx = backgroundCanvas.getContext('2d');
            bgCtx.fillStyle = backgroundColor;
            bgCtx.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        function generateDecorations() {
            decorations = [];
            for(let i = 0; i < 40; i++) {
                const x = Math.random() * canvasWidth; 
                const y = Math.random() * canvasHeight;
                if (!isNearPath(x, y, canvasWidth * 0.1)) {
                    const rand = Math.random();
                    if (rand < 0.5) { // 50% chance for a tree
                        decorations.push({ x, y, type: 'tree' });
                    } else if (rand < 0.85) { // 35% chance for flowers
                        decorations.push({ 
                            x, y, type: 'flowers', 
                            colors: Array(5).fill(0).map(()=>`hsl(${Math.random()*360}, 90%, 70%)`), 
                            pos: Array(5).fill(0).map(()=>({x: (Math.random()-0.5)*20, y: (Math.random()-0.5)*20})) 
                        });
                    } else { // 15% chance for mushrooms
                        decorations.push({ 
                            x, y, type: 'mushrooms', 
                            pos: Array(3).fill(0).map(()=>({x: (Math.random()-0.5)*15, y: (Math.random()-0.5)*10})) 
                        });
                    }
                }
            }
        }
        
        function createTowerButtons() {
            towerSelectionContainer.innerHTML = '';
            const towersToDisplay = isCustomGame ? customEnabledTowers : Object.keys(TOWER_DATA);

            const towerOrder = towersToDisplay.sort((a, b) => TOWER_DATA[a].cost - TOWER_DATA[b].cost);

            towerOrder.forEach(type => {
                const tower = TOWER_DATA[type];
                const button = document.createElement('button');
                button.className = 'tower-select-button p-2 bg-white rounded-lg shadow-md border-2 border-gray-300 transition-all w-32 text-center';
                
                const iconCanvas = document.createElement('canvas');
                iconCanvas.width = 64;
                iconCanvas.height = 64;
                iconCanvas.className = 'mx-auto';
                
                const nameP = document.createElement('p');
                nameP.className = 'font-semibold text-gray-700 text-sm';
                nameP.textContent = tower.name;

                const costP = document.createElement('p');
                costP.className = 'font-bold text-amber-600 text-sm';
                costP.textContent = `${tower.cost} Gold`;

                button.append(iconCanvas, nameP, costP);
                button.onclick = () => selectTower(type, button);
                towerSelectionContainer.appendChild(button);

                const iconCtx = iconCanvas.getContext('2d');
                drawTower({x:32, y:32, size:40, type:type, level: 1, holes: Array(5).fill(0).map(()=>({x:0,y:0})), fountainLevel: 10}, iconCtx);
            });
        }

        function selectTower(type, button) {
            if (TOWER_DATA[type].limit) {
                const existingTowers = towers.filter(t => t.type === type).length;
                if (existingTowers >= TOWER_DATA[type].limit) return;
            }
            if (selectedTowerType === type) {
                selectedTowerType = null; button.classList.remove('selected'); canvas.style.cursor = 'not-allowed';
            } else {
                selectedTowerType = type; selectedTower = null;
                document.querySelectorAll('.tower-select-button').forEach(b => b.classList.remove('selected'));
                button.classList.add('selected'); canvas.style.cursor = `crosshair`;
            }
        }

        function updateUI() { goldDisplay.textContent = Math.floor(gold); livesDisplay.textContent = Math.round(baseHealth); waveDisplay.textContent = wave; timerDisplay.textContent = waveTimer; }

        function startWaveTimer(startTime = 10) { 
            waveTimer = startTime; 
            updateUI(); 
            if (timerInterval) clearInterval(timerInterval); 
            if (waveInProgress || gameOver) return;
            timerInterval = setInterval(() => { 
                waveTimer--; 
                updateUI(); 
                if (waveTimer <= 0) { 
                    clearInterval(timerInterval); 
                    startNextWave(); 
                } 
            }, 1000 / gameSpeed); 
        }

        function startNextWave() {
            wave++; waveInProgress = true; bossWave = (wave % 10 === 0 && wave > 0); bossSpawned = false;
            
            if (wave >= 1000) { 
                hellModeActive = true; 
                demonModeActive = false; // Ensure demon mode is off
                flashHellAlert(); 
            } else if (wave >= 100) { 
                demonModeActive = true; 
                flashDemonAlert(); 
            }

            if (bossWave) flashBossAlert();
            
            let enemyCount;
            if (wave === 1) enemyCount = 5;
            else if (wave === 2) enemyCount = 8;
            else if (wave === 3) enemyCount = 12;
            else enemyCount = 10 + wave * 2;

            const enemyTypes = isCustomGame ? customEnabledEnemies : Object.keys(ENEMY_DATA);
            for (let i = 0; i < enemyCount; i++) {
                let enemyType = 'normal';
                if (wave > 1) {
                    const availableEnemyTypes = isCustomGame ? enemyTypes : enemyTypes.slice(0, Math.min(enemyTypes.length, 2 + Math.floor(wave / 3)));
                    enemyType = availableEnemyTypes[Math.floor(Math.random() * availableEnemyTypes.length)];
                }
                const data = ENEMY_DATA[enemyType];
                
                let waveHealthScaling = (currentDifficulty === 'hardcore') ? 0.12 : 0.18;
                let healthMultiplier = (1 + (wave * waveHealthScaling)) * enemyStrengthModifier * difficultyModifier.health;
                let speedMultiplier = enemySpeedModifier * difficultyModifier.speed;

                if (hellModeActive) {
                    healthMultiplier *= 600;
                    speedMultiplier *= 200;
                } else if (demonModeActive) {
                    healthMultiplier *= 150;
                    speedMultiplier *= 3;
                }

                const health = data.health * healthMultiplier;
                const speed = data.speed * speedMultiplier;
                let visual = {};
                if (enemyType === 'pbj') visual.color = `hsl(300, 50%, ${60 - wave * 1.5}%)`;
                else visual.color = `hsl(${20 + wave * 2}, 70%, 50%)`;
                enemies.push({ x: scaledPath[0].x - i * 40, y: scaledPath[0].y, pathIndex: 0, speed: speed, health: health, maxHealth: health, size: canvasWidth * 0.015 * (1 + wave * 0.02), gold: data.gold, type: enemyType, visual: visual, slowed: false, slowTimer: 0, isBurning: false, burnTimer: 0, burnDamage: 0, isFrozen: false, freezeTimer: 0, isShocked: false, shockTimer: 0, ability: data.ability || null, resistance: data.resistance || null, lastHitBy: null, attackingMonolith: null });
            }
            updateUI();
        }

        function spawnBoss() {
            bossSpawned = true; 
            const bossTypes = ['boss', 'burnt_beast', 'moldy_monarch', 'king_crumb'];
            const chosenBossType = bossTypes[Math.floor(Math.random() * bossTypes.length)];
            const data = ENEMY_DATA[chosenBossType]; 
            const waveMultiplier = wave / 10;

            let healthMultiplier = waveMultiplier * enemyStrengthModifier * difficultyModifier.health;
            let speedMultiplier = enemySpeedModifier * difficultyModifier.speed;

            if (hellModeActive) {
                healthMultiplier *= 600;
                speedMultiplier *= 200;
            } else if (demonModeActive) {
                healthMultiplier *= 150;
                speedMultiplier *= 3;
            }

            const bossHealth = data.health * healthMultiplier;
            const bossSize = canvasWidth * 0.02 * (2.5 + waveMultiplier * 0.5);
            const speed = data.speed * speedMultiplier;
            enemies.push({ x: scaledPath[0].x, y: scaledPath[0].y, pathIndex: 0, speed: speed, health: bossHealth, maxHealth: bossHealth, size: bossSize, gold: data.gold * waveMultiplier, type: chosenBossType, visual: { color: `hsl(0, 80%, ${40 - waveMultiplier*2}%)`}, slowed: false, slowTimer: 0, isBurning: false, burnTimer: 0, burnDamage: 0, isFrozen: false, freezeTimer: 0, isShocked: false, shockTimer: 0, lastHitBy: null, attackingMonolith: null, resistance: data.resistance || null });
        }

        function isNearPath(x, y, threshold) { for (let i = 0; i < scaledPath.length - 1; i++) { const p1 = scaledPath[i]; const p2 = scaledPath[i+1]; const dx = p2.x - p1.x; const dy = p2.y - p1.y; const l2 = dx * dx + dy * dy; if (l2 === 0) continue; let t = ((x - p1.x) * dx + (y - p1.y) * dy) / l2; t = Math.max(0, Math.min(1, t)); const closestX = p1.x + t * dx; const closestY = p1.y + t * dy; const dist = Math.hypot(x - closestX, y - closestY); if (dist < threshold) return true; } return false; }
        
        function canPlaceTower(x, y) {
            const towerSize = canvasWidth * 0.035;
            if (selectedTowerType === 'monolith') {
                return isNearPath(x, y, canvasWidth * 0.03) && !towers.some(t => Math.hypot(x - t.x, y - t.y) < towerSize);
            }
            for (const tower of towers) {
                if (Math.hypot(x - tower.x, y - tower.y) < towerSize) return false;
            }
            return !isNearPath(x, y, canvasWidth * 0.03);
        }

        function handleCanvasClick(e) {
            if (!audioStarted) setupAudio();
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left; const clickY = e.clientY - rect.top;
            
            if (selectedTower) {
                const { x, y, size, upgradeCost, level, type, totalSpent } = selectedTower;
                const menuWidth = 120; let menuHeight = 70;
                if (type === 'fondue') menuHeight += 35;
                const menuX = x + size/2 + 10; const menuY = y - menuHeight / 2;
                const btnX = menuX + menuWidth - 40; const btnY = menuY + 5;
                const sellBtnY = menuY + 40;
                
                if (clickX >= btnX && clickX <= btnX + 35 && clickY >= btnY && clickY <= btnY + 30) { if (gold >= upgradeCost) upgradeTower(selectedTower); return; }
                if (clickX >= menuX + 5 && clickX <= menuX + menuWidth - 5 && clickY >= sellBtnY && clickY <= sellBtnY + 25) { sellTower(selectedTower); return; }
                if (type === 'fondue' && selectedTower.fireCooldown <= 0) {
                    const specialBtnY = menuY + 75;
                    if (clickX >= menuX && clickX <= menuX + menuWidth && clickY >= specialBtnY && clickY <= specialBtnY + 30) {
                        selectedTower.fireCooldown = selectedTower.fireRate;
                        specialEffects.push({type: 'fondue_wave', x: canvasWidth/2, y: canvasHeight/2, radius: 0, maxDuration: 60, duration: 60, damage: selectedTower.damage });
                        return;
                    }
                }
            }

            for (const tower of towers) { if (Math.hypot(clickX - tower.x, clickY - tower.y) < tower.size / 2) { selectedTower = tower; selectedTowerType = null; document.querySelectorAll('.tower-select-button').forEach(b => b.classList.remove('selected')); canvas.style.cursor = 'default'; return; } }
            if (selectedTowerType) { placeTower(); } else { selectedTower = null; }
        }

        function sellTower(tower) {
            gold += Math.floor(tower.totalSpent / 2);
            towers = towers.filter(t => t !== tower);
            selectedTower = null;
            updateUI();
        }

        function upgradeTower(tower) {
            gold -= tower.upgradeCost;
            tower.totalSpent += tower.upgradeCost;
            tower.level++;
            const upgradeType = TOWER_DATA[tower.type].upgrade;
            if (upgradeType === 'damage') tower.damage *= 1.25;
            else if (upgradeType === 'fireRate') tower.fireRate *= 0.85;
            else if (upgradeType === 'effect') tower.damage *= 1.2;
            else if (upgradeType === 'cash') { tower.damage *= 1.5; tower.fireRate *= 0.9; }
            tower.upgradeCost *= 2;
            updateUI();
        }

        function placeTower() {
            if (gameOver || !selectedTowerType) return;
            const towerData = TOWER_DATA[selectedTowerType];
            if (towerData.limit) {
                const existingTowers = towers.filter(t => t.type === selectedTowerType).length;
                if (existingTowers >= towerData.limit) {
                    const button = Array.from(document.querySelectorAll('.tower-select-button')).find(b => b.textContent.includes(towerData.name));
                    if (button) {
                        button.classList.add('bg-red-300');
                        setTimeout(() => button.classList.remove('bg-red-300'), 500);
                    }
                    floatingTexts.push({x: mousePos.x, y: mousePos.y, content: `Limit Reached! (${towerData.limit})`, color: '255,0,0', duration: 60, size: 16});
                    return;
                }
            }
            if (gold < towerData.cost) { goldDisplay.classList.add('animate-pulse', 'text-red-600'); setTimeout(() => goldDisplay.classList.remove('animate-pulse', 'text-red-600'), 500); return; }
            if (canPlaceTower(mousePos.x, mousePos.y)) {
                gold -= towerData.cost;
                let newTower = { x: mousePos.x, y: mousePos.y, type: selectedTowerType, size: canvasWidth * 0.035, range: canvasWidth * towerData.range, fireRate: towerData.fireRate, fireCooldown: 0, damage: towerData.damage, projectileType: towerData.projectile, level: 1, upgradeCost: towerData.cost * 2, totalSpent: towerData.cost, shield: 0, disabled: 0, currentTarget: null, damageBonus: 0 };
                if (selectedTowerType === 'lazar' || selectedTowerType === 'gasser') newTower.holes = Array(5).fill(0).map(()=>({x: Math.random()-0.5, y: Math.random()-0.5}));
                if (selectedTowerType === 'fountain') newTower.fountainLevel = 5;
                if (selectedTowerType === 'monolith') {
                    newTower.health = towerData.health;
                    newTower.maxHealth = towerData.maxHealth;
                }
                towers.push(newTower); 
                playSound('build');
                updateUI();
            }
        }
        
        function update() {
            let totalCommanders = towers.filter(t=>t.type==='commander').length;
            let cotijaBonus = 1 + towers.filter(t=>t.type==='cotija_citadel').reduce((acc, t) => acc + t.damage, 0);
            let asiagoBonus = 1 + towers.filter(t=>t.type==='asiago_accelerator').reduce((acc, t) => acc + t.damage, 0);
            let pantheonChance = towers.filter(t=>t.type==='provolone_pantheon').reduce((acc, t) => acc + t.damage, 0);

            towers.forEach(t => { 
                t.currentFireRate = t.fireRate; 
                t.currentRange = t.range; 
                t.currentDamage = t.damage * cotijaBonus * asiagoBonus;
                if (t.disabled > 0) t.disabled--; 
            });
            if (totalCommanders > 0) { const commander = towers.find(t=>t.type==='commander'); if (commander) { towers.forEach(t => { if (t.type !== 'commander') { t.currentFireRate *= (1 - commander.damage * totalCommanders); t.currentRange *= (1 + commander.damage * totalCommanders); } }); } }
            towers.filter(t => t.type === 'prism').forEach(prism => { if (prism.disabled > 0) return; specialEffects.push({type: 'prism_aura', x: prism.x, y: prism.y, radius: prism.currentRange, duration: 2, maxDuration: 2}); towers.forEach(otherTower => { if (otherTower !== prism && Math.hypot(prism.x - otherTower.x, prism.y - otherTower.y) < prism.currentRange) { otherTower.currentFireRate *= (1 - prism.damage); } }); });
            
            towers.forEach(tower => {
                if (tower.disabled > 0) return;
                tower.fireCooldown--;

                if (Math.random() < pantheonChance && tower.fireCooldown > 10 && tower.type !== 'provolone_pantheon') {
                    let target = null;
                    enemies.forEach(enemy => { if (Math.hypot(enemy.x - tower.x, enemy.y - tower.y) < tower.currentRange) if (!target) target = enemy; });
                    if(target) projectiles.push({ originX: tower.x, originY: tower.y, x: tower.x, y: tower.y, target: target, speed: 10, damage: 500, size: 8, type: 'normal', color: 'gold', tower: tower });
                }

                if (tower.fireCooldown <= 0) {
                    if (['gold', 'colby_coin_op', 'mimolette_mint', 'vacherin_vault', 'fondue', 'mascarpone_matrix', 'cotija_citadel', 'provolone_pantheon', 'asiago_accelerator'].includes(tower.type)) { 
                        if (tower.type === 'gold' || TOWER_DATA[tower.type].upgrade === 'cash') { gold += tower.currentDamage; floatingTexts.push({x: tower.x, y: tower.y, content: `+${Math.round(tower.currentDamage)}`, color: '255,215,0', duration: 60, size: 16}); tower.fireCooldown = tower.currentFireRate; updateUI(); }
                        if (tower.type === 'mascarpone_matrix') { enemies.forEach(e => { if(Math.hypot(e.x - tower.x, e.y - tower.y) < tower.currentRange) e.slowed = true; e.slowTimer = 5; e.weakened = true; }); }
                        return; 
                    }
                    if (tower.type === 'fountain') { enemies.forEach(enemy => { if (Math.hypot(enemy.x - tower.x, enemy.y - tower.y) < tower.currentRange) { enemy.isBurning = true; enemy.burnTimer = 30; enemy.burnDamage = tower.currentDamage; if (!enemy.resistance?.includes('slow')) { enemy.slowed = true; enemy.slowTimer = 15; } } }); return; }
                    if (tower.type === 'monolith') { return; }
                    if (['hailstorm', 'wensleydale_whirlwind', 'jarlsberg_juggernaut', 'feta_fleet', 'asiago_annihilator', 'roquefort_rain', 'velveeta_volcano', 'raclette_reactor', 'epoisses_erupter', 'halloumi_hellstorm', 'stilton_supernova', 'cheddar_cataclysm', 'feta_freeze-frame', 'the_cheesus_christ'].includes(tower.type)) {
                         specialEffects.push({type: tower.projectileType, x: tower.x, y: tower.y, radius: tower.currentRange, duration: 120, maxDuration: 120, damage: tower.currentDamage}); tower.fireCooldown = tower.currentFireRate; return; 
                    }
                     if(tower.type === 'casu_marzus_call' || tower.type === 'muenster_monster' || tower.type === 'monterey_minefield'){
                         // Special spawn logic
                         if(tower.type === 'casu_marzus_call') for(let i = 0; i < 5; i++){ friendlyUnits.push({x: tower.x, y: tower.y, health: 100, damage: tower.damage, speed: 2, size: 5, target: null}); }
                         if(tower.type === 'muenster_monster') friendlyUnits.push({x: tower.x, y: tower.y, health: 1000, damage: tower.damage, speed: 0.5, size: 15, target: null, isGolem: true, duration: 600});
                         if(tower.type === 'monterey_minefield') specialEffects.push({type: 'mine', x: scaledPath[Math.floor(Math.random() * scaledPath.length)].x, y: scaledPath[Math.floor(Math.random() * scaledPath.length)].y, radius: 15, duration: Infinity, maxDuration: Infinity, damage: tower.damage});
                         tower.fireCooldown = tower.currentFireRate;
                         return;
                     }
                    
                    let target = null;
                    enemies.forEach(enemy => { if (Math.hypot(enemy.x - tower.x, enemy.y - tower.y) < tower.currentRange) if (!target) target = enemy; });
                    if (target) {
                        if (tower.type === 'assassin') { if (tower.currentTarget === target) { tower.damageBonus += 2; } else { tower.currentTarget = target; tower.damageBonus = 0; } }
                        let p = { originX: tower.x, originY: tower.y, x: tower.x, y: tower.y, target: target, speed: 8, damage: tower.currentDamage + (tower.damageBonus || 0), size: 5, type: tower.projectileType, tower: tower };
                        if ((p.type === 'slow' || p.type === 'singularity_slow') && !p.target.resistance?.includes('slow')) { p.color = '#FFA500'; p.slowDuration = 300; }
                        else if (p.type === 'lazar' || p.type === 'continuous_lazar') { p.color = '#FFFF00'; p.duration = 10; p.burnDuration = 240; p.burnDamage = p.damage / 4; }
                        else if (['bomb', 'rocket', 'blimp_bomb', 'carpet_bomb', 'shock_blast', 'meteor', 'moonfall'].includes(p.type)) { 
                            p.color = '#2F4F4F'; 
                            p.blastRadius = canvasWidth * (p.type==='rocket' ? 0.07 : (p.type === 'carpet_bomb' ? 0.12 : (p.type === 'meteor' ? 0.1 : (p.type === 'moonfall' ? 0.25 : 0.05)))); 
                            p.detonated = false; 
                            p.blastDuration = 15; 
                            if(p.type === 'carpet_bomb') p.blastColor = `rgba(255, 0, 0, ${p.blastDuration / 15})`;
                            if(p.type === 'shock_blast') p.blastColor = `rgba(255, 255, 0, ${p.blastDuration / 15})`;
                        }
                        else if (p.type === 'pierce' || p.type === 'super_pierce') { p.color = '#FF4500'; }
                        else if (p.type === 'gas_cloud') { specialEffects.push({type: 'gas_cloud', x: target.x, y: target.y, radius: canvasWidth * 0.06, duration: 300, maxDuration: 300, damage: p.damage}); }
                        else if (p.type === 'bounce') { p.color = '#E0E0E0'; p.bouncesLeft = 2; }
                        else if (p.type === 'chain_infinite' || p.type === 'chain_decay') { p.color = 'cyan'; p.bouncesLeft = p.type === 'chain_infinite' ? 99 : 5; }
                        else if (p.type === 'brie_rocket') { p.color = '#DEB887'; p.speed = 4; p.size = 15; p.targetX = target.x; p.targetY = target.y; p.originalTarget = target; }
                        else if (p.type === 'freeze' && !p.target.resistance?.includes('freeze')) { p.color = '#00FFFF'; p.freezeDuration = 120; }
                        else if (p.type === 'flamethrower') { p.color = 'orange'; }
                        else if (p.type === 'barrage') { for(let i=0; i<50; i++){ projectiles.push({...p, targetX: Math.random()*canvasWidth, targetY: Math.random()*canvasHeight}); } }
                        else if (p.type === 'trap') { target.isTrapped = true; target.trapDamage = p.damage; target.trapDuration = 300; }
                        else if (p.type === 'quattro') {
                            projectiles.push({...p, type: 'pierce', color: 'red'});
                            projectiles.push({...p, type: 'bomb', blastRadius: canvasWidth * 0.05, detonated: false, blastDuration: 15});
                            projectiles.push({...p, type: 'slow', color: 'blue', slowDuration: 180});
                            projectiles.push({...p, type: 'bounce', color: 'white', bouncesLeft: 3});
                        }
                        else { p.color = '#FFC107'; }

                        if (!['gas_cloud', 'barrage', 'trap', 'quattro'].includes(p.type)) projectiles.push(p);
                        tower.fireCooldown = tower.currentFireRate;
                        playSound(p.type === 'lazar' ? 'lazar' : 'shoot');
                    } else { if (tower.type === 'assassin') tower.currentTarget = null; tower.damageBonus = 0; }
                }
            });

            specialEffects.forEach(effect => { 
                if (['gas_cloud', 'large_gas_cloud', 'hailstorm', 'fire_storm', 'fire_trail', 'meteor', 'rift'].includes(effect.type)) { 
                    enemies.forEach(enemy => { 
                        if (Math.hypot(enemy.x - effect.x, enemy.y - effect.y) < effect.radius) { 
                            enemy.health -= effect.damage / 60; 
                            if (effect.type === 'hailstorm' && Math.random() < 0.01 && !enemy.resistance?.includes('freeze')) enemy.freezeTimer = 10; 
                        } 
                    }); 
                } else if (effect.type === 'vortex' || effect.type === 'super_vortex' || effect.type === 'black_hole') { 
                    enemies.forEach(enemy => { 
                        if (Math.hypot(enemy.x - effect.x, enemy.y - effect.y) < effect.radius) { 
                            enemy.health -= effect.damage / 60; 
                            if (!enemy.resistance?.includes('slow')) { enemy.slowed = true; enemy.slowTimer = 10; } 
                        } 
                    }); 
                } else if (effect.type === 'fondue_wave' || effect.type === 'reactor_blast' || effect.type === 'supernova_blast' || effect.type === 'rapture' || effect.type === 'screen_shake_damage') { 
                    effect.radius += canvasWidth/30; enemies.forEach(e => e.health -= effect.damage/60); 
                } else if (effect.type === 'spore_cloud' && effect.towerToDisable) { 
                    effect.towerToDisable.disabled = ENEMY_DATA['moldy'].duration; specialEffects.splice(specialEffects.indexOf(effect), 1); 
                } else if (effect.type === 'popper_explosion') { 
                    towers.forEach(t => { 
                        if (Math.hypot(t.x - effect.x, t.y - effect.y) < effect.radius) { 
                            let damageDealt = effect.damage; if (t.shield > 0) { const shieldDamage = Math.min(t.shield, damageDealt); t.shield -= shieldDamage; } 
                        } 
                    }); specialEffects.splice(specialEffects.indexOf(effect), 1); 
                } else if (effect.type === 'heal_aura') {
                    enemies.forEach(e => {
                        if (e !== effect.source && Math.hypot(e.x - effect.x, e.y - effect.y) < effect.radius) {
                            e.health = Math.min(e.maxHealth, e.health + 10 / 60);
                        }
                    });
                } else if (effect.type === 'speed_aura' || effect.type === 'buff_aura') {
                    enemies.forEach(e => {
                        if (e !== effect.source && Math.hypot(e.x - effect.x, e.y - effect.y) < effect.radius) {
                            e.isBuffed = true;
                        }
                    });
                } else if (effect.type === 'global_freeze') {
                    enemies.forEach(e => { if(!e.resistance?.includes('freeze')) { e.isFrozen = true; e.freezeTimer = 300; e.vulnerable = true; } });
                    specialEffects.splice(specialEffects.indexOf(effect), 1);
                } else if (effect.type === 'mine') {
                    enemies.forEach(e => {
                        if(Math.hypot(e.x-effect.x, e.y-effect.y) < effect.radius){
                            specialEffects.push({type: 'popper_explosion', x: effect.x, y: effect.y, radius: 50, duration: 10, maxDuration: 10, damage: effect.damage});
                            effect.duration = 0; // remove mine
                        }
                    });
                }
            });

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                if (p.detonated) { p.blastDuration--; if (p.blastDuration <= 0) projectiles.splice(i, 1); continue; }
                if (p.type === 'lazar' || p.type === 'continuous_lazar') { p.duration--; if (p.target) { p.x = p.target.x; p.y = p.target.y; if(!p.target.phasing){p.target.health -= p.damage;} } if (p.duration <= 0) projectiles.splice(i, 1); continue; }
                
                if (p.type === 'brie_rocket' || p.type === 'barrage') {
                    const dx = p.targetX - p.x;
                    const dy = p.targetY - p.y;
                    const dist = Math.hypot(dx, dy);

                    if (dist < p.speed) {
                        projectiles.splice(i, 1);
                    } else {
                        p.x += (dx / dist) * p.speed;
                        p.y += (dy / dist) * p.speed;
                    }

                    if (p.originalTarget && p.originalTarget.health > 0 && !p.originalTarget.phasing) {
                        const hitDist = Math.hypot(p.x - p.originalTarget.x, p.y - p.originalTarget.y);
                        if (hitDist < p.originalTarget.size) {
                            p.originalTarget.health -= p.damage;
                            p.originalTarget.lastHitBy = p.tower;
                            projectiles.splice(i, 1);
                        }
                    }
                    continue;
                }
                
                if (p.type === 'god_hand') {
                    if (Math.random() < 0.25 && p.target.type !== 'boss') { p.target.health = 0; }
                }

                if (p.type === 'rewind_group') {
                    const strongest = p.target;
                    strongest.pathIndex = 0;
                    strongest.x = scaledPath[0].x;
                    strongest.y = scaledPath[0].y;
                    strongest.health *= 0.8; // Weaken
                    enemies.forEach(e => {
                        if(e !== strongest && Math.hypot(e.x - strongest.x, e.y - strongest.y) < 100){
                           e.pathIndex = 0;
                           e.x = scaledPath[0].x - 20;
                           e.y = scaledPath[0].y;
                        }
                    });
                    projectiles.splice(i,1);
                    continue;
                }

                if (!p.target || p.target.health <= 0 || p.target.phasing) { projectiles.splice(i, 1); continue; }
                const dx = p.target.x - p.x; const dy = p.target.y - p.y; const dist = Math.hypot(dx, dy);
                if (dist < p.speed) {
                    let damageDealt = p.damage; p.target.lastHitBy = p.tower;
                    if(p.target.vulnerable) damageDealt *= 1.5;

                    if (['bomb', 'rocket', 'blimp_bomb', 'carpet_bomb', 'shock_blast', 'meteor', 'moonfall'].includes(p.type)) { 
                        p.detonated = true; 
                        playSound('explode'); 
                        enemies.forEach(enemy => { 
                            if (Math.hypot(enemy.x - p.target.x, enemy.y - p.target.y) < p.blastRadius) { 
                                let splashDamage = damageDealt;
                                if(enemy.vulnerable) splashDamage *= 1.5;
                                enemy.health -= splashDamage; 
                                enemy.lastHitBy = p.tower; 
                                if(p.type === 'shock_blast') {
                                    enemy.isShocked = true;
                                    enemy.shockTimer = 180;
                                }
                                if(p.type === 'moonfall'){
                                    enemy.slowed = true;
                                    enemy.slowTimer = 300;
                                }
                            } 
                        }); 
                    } else {
                        p.target.health -= damageDealt;
                        if(p.type === 'infection_explosion') p.target.isInfected = true;

                        if ((p.type === 'slow' || p.type === 'singularity_slow') && !p.target.resistance?.includes('slow')) { p.target.slowed = true; p.target.slowTimer = p.slowDuration; }
                        if (p.type === 'freeze' && !p.target.resistance?.includes('freeze')) { p.target.isFrozen = true; p.target.freezeTimer = p.freezeDuration; }
                        if (p.type === 'pierce') { p.target.health -= p.target.maxHealth * 0.05; }
                        if (p.type === 'lazar' || p.type === 'smite_beam') { p.target.isBurning = true; p.target.burnTimer = p.burnDuration || 240; p.target.burnDamage = p.burnDamage || damageDealt / 4; }
                        if ((p.type === 'bounce' || p.type === 'chain_infinite' || p.type === 'chain_decay') && p.bouncesLeft > 0) {
                            p.bouncesLeft--; let nextTarget = null; let minDist = Infinity;
                            if(p.type === 'chain_decay') p.damage *= 0.8;
                            enemies.forEach(e => { if (e !== p.target && e.health > 0 && !e.isBounced) { const d = Math.hypot(p.target.x - e.x, p.target.y - e.y); if (d < minDist) { minDist = d; nextTarget = e; } } });
                            if (nextTarget) { p.target = nextTarget; p.target.isBounced = true; } else { projectiles.splice(i, 1); }
                        } else if (!p.detonated) { 
                            projectiles.splice(i, 1); 
                        }
                    }
                } else { 
                    p.x += (dx / dist) * p.speed; 
                    p.y += (dy / dist) * p.speed; 
                }
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.isBounced = false; // Reset for next frame
                enemy.isBuffed = false; // Reset for next frame

                // --- MONOLITH BLOCKING LOGIC ---
                if (enemy.attackingMonolith && enemy.attackingMonolith.health <= 0) {
                    enemy.attackingMonolith = null;
                }

                if (enemy.attackingMonolith) {
                    enemy.attackingMonolith.health -= (enemy.maxHealth * 0.005) / 60; // Deal damage
                    if (enemy.attackingMonolith.health <= 0) {
                        const destroyedMonolith = enemy.attackingMonolith;
                        towers = towers.filter(t => t !== destroyedMonolith);
                        if (selectedTower === destroyedMonolith) selectedTower = null;
                        enemy.attackingMonolith = null;
                    }
                    continue; // Skip movement if attacking
                }

                let isBlocked = false;
                for (const tower of towers) {
                    if (tower.type === 'monolith' && tower.health > 0) {
                        const distToMonolith = Math.hypot(enemy.x - tower.x, enemy.y - tower.y);
                        if (distToMonolith < enemy.size + tower.size / 2 + 5) {
                            enemy.attackingMonolith = tower;
                            isBlocked = true;
                            break;
                        }
                    }
                }
                if (isBlocked) continue;
                // --- END MONOLITH LOGIC ---


                if (enemy.health <= 0) { 
                    playSound('death');
                    const onDeath = ENEMY_DATA[enemy.type];
                    if(enemy.isInfected){
                         enemies.forEach(e => {
                             if(e !== enemy && Math.hypot(e.x - enemy.x, e.y - enemy.y) < 50){
                                 e.isInfected = true;
                             }
                         });
                    }

                    if (onDeath.onDeath === 'explode') {
                        specialEffects.push({type: 'popper_explosion', x: enemy.x, y: enemy.y, radius: canvasWidth * onDeath.radius, duration: 10, maxDuration: 10, damage: onDeath.damage});
                    }
                     if (onDeath.onDeath === 'explode_kamikaze') {
                        specialEffects.push({type: 'popper_explosion', x: enemy.x, y: enemy.y, radius: canvasWidth * onDeath.radius, duration: 10, maxDuration: 10, damage: onDeath.damage});
                    }
                    if (onDeath.onDeath === 'disable' || onDeath.onDeath === 'disable_large') { 
                        towers.forEach(t => {
                            if (Math.hypot(t.x - enemy.x, t.y - enemy.y) < canvasWidth * onDeath.radius) {
                                t.disabled = onDeath.duration;
                            }
                        });
                    }
                    if (onDeath.onDeath === 'spawn') {
                        for (let j = 0; j < onDeath.spawnCount; j++) {
                            const newEnemyData = ENEMY_DATA[onDeath.spawnType];
                            const newEnemy = {
                                x: enemy.x - (j * 10), y: enemy.y, pathIndex: enemy.pathIndex, speed: newEnemyData.speed, health: newEnemyData.health, maxHealth: newEnemyData.health, size: canvasWidth * 0.015, gold: newEnemyData.gold, type: onDeath.spawnType, visual: { color: `hsl(${20 + wave * 2}, 70%, 50%)` }, slowed: false, slowTimer: 0, isBurning: false, burnTimer: 0, burnDamage: 0, isFrozen: false, freezeTimer: 0, isShocked: false, shockTimer: 0, ability: newEnemyData.ability || null, lastHitBy: null, attackingMonolith: null
                            };
                            enemies.push(newEnemy);
                        }
                    }
                    gold += enemy.gold; 
                    enemies.splice(i, 1); 
                    updateUI(); 
                    continue; 
                }
                if (enemy.isFrozen) { enemy.freezeTimer--; if (enemy.freezeTimer <= 0) { enemy.isFrozen = false; enemy.vulnerable = false; } continue; }
                if (enemy.isTrapped) { enemy.trapDuration--; enemy.health -= enemy.trapDamage/300; if(enemy.trapDuration <= 0) enemy.isTrapped = false; continue;}
                if (enemy.slowed) { enemy.slowTimer--; if (enemy.slowTimer <= 0) enemy.slowed = false; }
                if (enemy.isShocked) { enemy.shockTimer--; if (enemy.shockTimer <= 0) enemy.isShocked = false; else { enemy.health -= 5; } }
                if (enemy.isBurning) { enemy.health -= enemy.burnDamage / 60; enemy.burnTimer--; if (enemy.burnTimer <= 0) enemy.isBurning = false; }
                if (enemy.ability === 'regenerate' && enemy.health < enemy.maxHealth) { enemy.health += (ENEMY_DATA[enemy.type].regenRate / 60); }
                if(enemy.isInfected) enemy.health -= 1000/60;
                
                // Handle new abilities
                if(enemy.ability === 'fire_trail' && frameCount % 10 === 0) { specialEffects.push({type: 'fire_trail', x: enemy.x, y: enemy.y, radius: 10, duration: 120, maxDuration: 120, damage: 5}); }
                if(enemy.ability === 'teleport' && frameCount % 180 === 0) { enemy.pathIndex = Math.min(enemy.pathIndex + 1, scaledPath.length - 2); enemy.x = scaledPath[enemy.pathIndex].x; enemy.y = scaledPath[enemy.pathIndex].y; }
                if(enemy.ability === 'heal_aura' && frameCount % 30 === 0) { specialEffects.push({type: 'heal_aura', x: enemy.x, y: enemy.y, radius: canvasWidth * 0.05, duration: 2, maxDuration: 2, source: enemy}); }
                if(enemy.ability === 'speed_aura' && frameCount % 10 === 0) { specialEffects.push({type: 'speed_aura', x: enemy.x, y: enemy.y, radius: canvasWidth * 0.06, duration: 2, maxDuration: 2, source: enemy}); }
                if(enemy.ability === 'phase') { if(frameCount % 300 === 0) { enemy.phasing = true; enemy.phaseTimer = 120; } if(enemy.phasing) { enemy.phaseTimer--; if(enemy.phaseTimer <= 0) enemy.phasing = false; } }
                if(enemy.ability === 'split' && enemy.health < enemy.maxHealth / 2 && !enemy.hasSplit) {
                    enemy.hasSplit = true;
                    enemy.health /= 2;
                    enemy.maxHealth /=2;
                    const newEnemy = { ...enemy, speed: enemy.speed * 1.5, size: enemy.size * 0.75, gold: Math.floor(enemy.gold / 2) };
                    enemies.push(newEnemy);
                }

                const currentSpeed = (enemy.slowed || enemy.isShocked) ? (enemy.isBuffed ? enemy.speed * 1.5 * 0.5 : enemy.speed * 0.5) : (enemy.isBuffed ? enemy.speed * 1.5 : enemy.speed);
                let targetPoint = scaledPath[enemy.pathIndex + 1];
                if (!targetPoint) { 
                    if (!isBaseInvincible) {
                        if(enemy.ability === 'steal') {
                            gold = Math.max(0, gold - 50);
                            floatingTexts.push({x: enemy.x, y: enemy.y, content: '-50 Gold!', color: '255,0,0', duration: 120, size: 20});
                        } else {
                            baseHealth -= enemy.maxHealth * 0.5; 
                        }
                        enemyStrengthModifier += 0.015; 
                    }
                    enemies.splice(i, 1); 
                    updateUI(); 
                    if (baseHealth <= 0) endGame(false); 
                    continue; 
                }
                const dx = targetPoint.x - enemy.x; const dy = targetPoint.y - enemy.y; const dist = Math.hypot(dx, dy);
                if (dist < currentSpeed) enemy.pathIndex++;
                else { enemy.x += (dx / dist) * currentSpeed; enemy.y += (dy / dist) * currentSpeed; }
            }

            for(let i = friendlyUnits.length - 1; i >=0; i--){
                const unit = friendlyUnits[i];
                if(unit.health <= 0 || (unit.duration && --unit.duration <= 0)) { friendlyUnits.splice(i,1); continue; }

                if(!unit.target || unit.target.health <= 0) {
                    let closestDist = Infinity;
                    let closestEnemy = null;
                    enemies.forEach(e => {
                        const dist = Math.hypot(unit.x - e.x, unit.y - e.y);
                        if(dist < closestDist){
                            closestDist = dist;
                            closestEnemy = e;
                        }
                    });
                    unit.target = closestEnemy;
                }
                
                if(unit.target) {
                    const dx = unit.target.x - unit.x;
                    const dy = unit.target.y - unit.y;
                    const dist = Math.hypot(dx, dy);

                    if(dist < unit.target.size){
                        unit.target.health -= unit.damage / 60;
                    } else {
                        unit.x += (dx/dist) * unit.speed;
                        unit.y += (dy/dist) * unit.speed;
                    }
                }
            }
            
            if (waveInProgress && enemies.length === 0) { if (bossWave && !bossSpawned) spawnBoss(); else { waveInProgress = false; gold += 100 + wave * 10; updateUI(); startWaveTimer(); } }
        }

        function draw() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // Draw pre-rendered background
            if (backgroundCanvas) {
                ctx.drawImage(backgroundCanvas, 0, 0);
            }

            if (demonModeActive || hellModeActive) { ctx.fillStyle = 'rgba(255, 0, 0, 0.25)'; ctx.fillRect(0, 0, canvasWidth, canvasHeight); }
            
            ctx.strokeStyle = '#A0522D'; ctx.lineWidth = canvasWidth * 0.06; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(scaledPath[0].x, scaledPath[0].y); for (let i = 1; i < scaledPath.length; i++) ctx.lineTo(scaledPath[i].x, scaledPath[i].y); ctx.stroke();
            
            drawDecorations();
            drawBase();
            
            if (selectedTowerType) { const towerData = TOWER_DATA[selectedTowerType]; const placeable = canPlaceTower(mousePos.x, mousePos.y); ctx.beginPath(); ctx.arc(mousePos.x, mousePos.y, canvasWidth * towerData.range, 0, Math.PI * 2); ctx.fillStyle = placeable ? 'rgba(255, 255, 255, 0.3)' : 'rgba(255, 0, 0, 0.3)'; ctx.fill(); }
            if (selectedTower) { ctx.strokeStyle = 'yellow'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(selectedTower.x, selectedTower.y, selectedTower.currentRange, 0, Math.PI*2); ctx.stroke(); }
            
            towers.forEach(tower => drawTower(tower, ctx));
            drawSpecialEffects();
            projectiles.forEach(drawProjectile);
            friendlyUnits.forEach(drawFriendlyUnit);
            enemies.forEach(enemy => { drawEnemy(enemy, ctx); const healthBarWidth = enemy.size * 1.5; ctx.fillStyle = '#DC2626'; ctx.fillRect(enemy.x - healthBarWidth / 2, enemy.y - enemy.size - 10, healthBarWidth, 5); ctx.fillStyle = enemy.slowed ? '#3498DB' : '#22C55E'; ctx.fillRect(enemy.x - healthBarWidth / 2, enemy.y - enemy.size - 10, healthBarWidth * (enemy.health / enemy.maxHealth), 5); });
            drawFloatingTexts();
            drawUpgradeMenu();
        }

        function gameLoop() { 
            if (!gameHasStarted) return;

            if (!isPaused && !gameOver) {
                for (let i = 0; i < gameSpeed; i++) {
                    frameCount++;
                    update();
                }
            }
            
            draw(); // Always draw to show the current state (playing or paused)
        }

        function togglePause() {
            if (!gameHasStarted) return;
            isPaused = !isPaused;
            if (isPaused) {
                clearInterval(timerInterval);
                pauseOverlay.classList.remove('hidden');
                pauseButton.innerHTML = '▶';
            } else {
                startWaveTimer(waveTimer); // Restart timer with remaining time
                pauseOverlay.classList.add('hidden');
                pauseButton.innerHTML = '❚❚';
            }
        }

        function setGameSpeed(speed) {
            if (!gameHasStarted) return;
            gameSpeed = speed;
            
            document.querySelectorAll('.speed-button').forEach(b => b.classList.remove('active'));
            if (speed === 1) {
                normalSpeedButton.classList.add('active');
                speedIndicator.classList.add('hidden');
            } else if (speed === 2) {
                twoxSpeedButton.classList.add('active');
                speedIndicator.textContent = '2x Speed';
                speedIndicator.classList.remove('hidden');
            } else {
                speedIndicator.textContent = `${speed}x Speed`;
                speedIndicator.classList.remove('hidden');
            }


            if (!waveInProgress && !isPaused) {
                clearInterval(timerInterval);
                startWaveTimer(waveTimer);
            }
        }

        function endGame(isWin) { gameOver = true; clearInterval(gameInterval); clearInterval(timerInterval); gameOverModal.classList.remove('hidden'); setTimeout(() => gameOverModal.classList.remove('opacity-0', 'scale-90'), 10); if (isWin) { gameOverTitle.textContent = "You Win!"; gameOverMessage.textContent = "Congratulations! You are the Grilled Cheese Champion!"; } else { gameOverTitle.textContent = "Game Over"; gameOverMessage.textContent = "Your home base has been devoured!"; } }
        
        function flashBossAlert() { bossAlert.classList.remove('hidden'); setTimeout(() => bossAlert.classList.remove('opacity-0'), 10); setTimeout(() => { bossAlert.classList.add('opacity-0'); setTimeout(() => bossAlert.classList.add('hidden'), 300); }, 2000); }
        function flashDemonAlert() { demonModeAlert.classList.remove('hidden'); setTimeout(() => demonModeAlert.classList.remove('opacity-0'), 10); setTimeout(() => { demonModeAlert.classList.add('opacity-0'); setTimeout(() => demonModeAlert.classList.add('hidden'), 3000); }, 2500); }
        function flashHellAlert() { hellModeAlert.classList.remove('hidden'); setTimeout(() => hellModeAlert.classList.remove('opacity-0'), 10); setTimeout(() => { hellModeAlert.classList.add('opacity-0'); setTimeout(() => hellModeAlert.classList.add('hidden'), 3000); }, 2500); }

        function populateIndex() {
            enemyIndexContent.innerHTML = '';
             const enemyOrder = Object.keys(ENEMY_DATA).sort((a,b) => ENEMY_DATA[a].health - ENEMY_DATA[b].health);
            enemyOrder.forEach(type => {
                const enemyData = ENEMY_DATA[type];
                const enemyDesc = ENEMY_DESCRIPTIONS[type];
                if (!enemyDesc) return;

                const entry = document.createElement('div');
                entry.className = 'flex items-center bg-white p-2 rounded-lg shadow';

                const iconCanvas = document.createElement('canvas');
                iconCanvas.width = 64;
                iconCanvas.height = 64;
                entry.appendChild(iconCanvas);

                const infoDiv = document.createElement('div');
                infoDiv.className = 'ml-4 text-left';
                
                const nameP = document.createElement('p');
                nameP.className = 'font-bold text-lg text-amber-800';
                nameP.textContent = enemyDesc.name;
                infoDiv.appendChild(nameP);

                const statsP = document.createElement('p');
                statsP.className = 'text-sm text-gray-600';
                let abilityText = enemyData.ability ? `, Ability: ${enemyData.ability}` : (enemyData.onDeath ? `, On Death: ${enemyData.onDeath}` : '');
                statsP.textContent = `HP: ${enemyData.health} | Speed: ${enemyData.speed} | Gold: ${enemyData.gold}${abilityText}`;
                infoDiv.appendChild(statsP);

                const descP = document.createElement('p');
                descP.className = 'text-sm text-gray-800 mt-1';
                descP.textContent = enemyDesc.description;
                infoDiv.appendChild(descP);

                entry.appendChild(infoDiv);
                enemyIndexContent.appendChild(entry);

                const iconCtx = iconCanvas.getContext('2d');
                drawEnemy({x:32, y:32, size:15, type:type, visual: {color: 'hsl(30, 70%, 50%)'}}, iconCtx);
            });
            
            towerIndexContent.innerHTML = '';
            const towerOrder = Object.keys(TOWER_DATA).sort((a, b) => TOWER_DATA[a].cost - TOWER_DATA[b].cost);
            towerOrder.forEach(type => {
                const towerData = TOWER_DATA[type];
                const entry = document.createElement('div');
                entry.className = 'flex items-center bg-white p-2 rounded-lg shadow';

                const iconCanvas = document.createElement('canvas');
                iconCanvas.width = 64;
                iconCanvas.height = 64;
                entry.appendChild(iconCanvas);

                const infoDiv = document.createElement('div');
                infoDiv.className = 'ml-4 text-left flex-grow';
                
                const nameP = document.createElement('p');
                nameP.className = 'font-bold text-lg text-amber-800';
                nameP.textContent = towerData.name;
                infoDiv.appendChild(nameP);

                const statsP = document.createElement('p');
                statsP.className = 'text-sm text-gray-600';
                let statsText = `Cost: ${towerData.cost}`;
                if (towerData.upgrade === 'cash') {
                    statsText += ` | Cash/tick: ${towerData.damage} | Cooldown: ${towerData.fireRate}`;
                } else if (type === 'monolith') {
                    statsText += ` | Health: ${towerData.health}`;
                } else if (towerData.damage !== Infinity) {
                    statsText += ` | Damage: ${towerData.damage} | Cooldown: ${towerData.fireRate} | Range: ${towerData.range * 100}`;
                } else {
                    statsText += ` | Damage: Infinite | Cooldown: ${towerData.fireRate} | Range: Global`;
                }
                statsP.textContent = statsText;
                infoDiv.appendChild(statsP);
                
                const descP = document.createElement('p');
                descP.className = 'text-sm text-gray-800 mt-1';
                descP.textContent = towerData.description;
                infoDiv.appendChild(descP);

                entry.appendChild(infoDiv);
                towerIndexContent.appendChild(entry);

                const iconCtx = iconCanvas.getContext('2d');
                drawTower({x:32, y:32, size:40, type:type, level: 1, holes: Array(5).fill(0).map(()=>({x:0,y:0})), fountainLevel: 10}, iconCtx);
            });
        }

        // --- Save and Load ---
        function saveGame() {
            if (!gameHasStarted || gameOver) return;

            const savableTowers = towers.map(t => {
                return {
                    x: t.x / canvasWidth, y: t.y / canvasHeight, // Save as ratios
                    type: t.type, level: t.level, totalSpent: t.totalSpent,
                };
            });

            const gameState = {
                gold: gold, wave: wave, baseHealth: baseHealth, towers: savableTowers,
                currentDifficulty: currentDifficulty,
                waveInProgress: waveInProgress, waveTimer: waveTimer,
                enemyStrengthModifier: enemyStrengthModifier, enemySpeedModifier: enemySpeedModifier
            };

            localStorage.setItem('gctd_save', JSON.stringify(gameState));

            floatingTexts.push({ x: canvasWidth / 2, y: canvasHeight / 2, content: 'Game Saved!', color: '0, 255, 0', duration: 120, size: 40 });
            playSound('build');
        }

        function loadGame() {
            const savedDataString = localStorage.getItem('gctd_save');
            if (!savedDataString) { console.error("No save data found."); return; }
            const savedState = JSON.parse(savedDataString);
            isCustomGame = false;
            init(savedState.currentDifficulty);

            gold = savedState.gold;
            wave = savedState.wave;
            baseHealth = savedState.baseHealth;
            enemyStrengthModifier = savedState.enemyStrengthModifier || 1.0;
            enemySpeedModifier = savedState.enemySpeedModifier || 1.0;
            
            towers = savedState.towers.map(st => {
                const baseTowerData = originalTowerData[st.type];
                let loadedTower = {
                    ...baseTowerData, // Start with original stats
                    x: st.x * canvasWidth, y: st.y * canvasHeight,
                    type: st.type, level: st.level, totalSpent: st.totalSpent,
                    size: canvasWidth * 0.035,
                    range: canvasWidth * baseTowerData.range,
                    upgradeCost: baseTowerData.cost,
                    fireCooldown: 0, shield: 0, disabled: 0, currentTarget: null, damageBonus: 0,
                };

                // Re-apply upgrades based on level
                for(let i = 1; i < st.level; i++) {
                    const upgradeType = TOWER_DATA[st.type].upgrade;
                    if (upgradeType === 'damage') loadedTower.damage *= 1.25;
                    else if (upgradeType === 'fireRate') loadedTower.fireRate *= 0.85;
                    else if (upgradeType === 'effect') loadedTower.damage *= 1.2;
                    else if (upgradeType === 'cash') { loadedTower.damage *= 1.5; loadedTower.fireRate *= 0.9; }
                    loadedTower.upgradeCost *= 2;
                }

                if (st.type === 'monolith') {
                    loadedTower.health = st.health;
                    loadedTower.maxHealth = st.maxHealth;
                }

                return loadedTower;
            });

            gameHasStarted = true;
            modeSelectModal.classList.add('hidden');
            
            waveInProgress = savedState.waveInProgress;
            waveTimer = savedState.waveTimer;
            updateUI();

            if (waveInProgress) {
                 startNextWave(); // This logic might need adjustment depending on how you want to respawn mid-wave enemies. For now, we restart the wave.
                 wave--; // Counteract the wave++ in startNextWave
            } else {
                startWaveTimer(waveTimer);
            }
        }

        function checkForSave() {
            const savedDataString = localStorage.getItem('gctd_save');
            if (savedDataString) {
                try {
                    const savedData = JSON.parse(savedDataString);
                    continueButton.classList.remove('hidden');
                    continueInfo.textContent = `Wave: ${savedData.wave} | Gold: ${savedData.gold} | ${savedData.currentDifficulty}`;
                } catch (e) {
                    console.error("Failed to parse save data:", e);
                    localStorage.removeItem('gctd_save');
                }
            } else {
                continueButton.classList.add('hidden');
            }
        }

        // --- Event Listeners ---
        window.addEventListener('resize', () => {
            if (gameHasStarted) {
                 resizeCanvas();
            } else {
                resizeCanvas();
            }
        });
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousemove', e => { const rect = canvas.getBoundingClientRect(); mousePos.x = e.clientX - rect.left; mousePos.y = e.clientY - rect.top; });
        
        restartButton.addEventListener('click', () => {
            if (isMusicPlaying) {
                toggleMusic();
                musicToggle.checked = false;
            }
            gameHasStarted = false;
            preGameOverlay.style.display = 'none';
            modeSelectModal.classList.remove('hidden');
            gameOverModal.classList.add('hidden');
            checkForSave();
            
            goldDisplay.textContent = 100;
            livesDisplay.textContent = 1500;
            waveDisplay.textContent = 0;
            timerDisplay.textContent = '--';
        });

        soundToggleButton.addEventListener('click', toggleSound);
        pauseButton.addEventListener('click', togglePause);
        normalSpeedButton.addEventListener('click', () => setGameSpeed(1));
        twoxSpeedButton.addEventListener('click', () => setGameSpeed(2));
        
        const startFunction = (e) => {
            e.preventDefault();
            document.getElementById('game-section').scrollIntoView();
            modeSelectModal.classList.remove('hidden');
            preGameOverlay.style.display = 'none';
            checkForSave();
        };

        startGameButton.addEventListener('click', startFunction);
        playNowButton.addEventListener('click', startFunction);

        normalModeButton.addEventListener('click', () => {
            modeSelectModal.classList.add('hidden');
            if(!gameHasStarted) {
                isCustomGame = false;
                init('normal');
                gameHasStarted = true;
            }
        });
        hardModeButton.addEventListener('click', () => {
            modeSelectModal.classList.add('hidden');
            if(!gameHasStarted) {
                isCustomGame = false;
                init('hard');
                gameHasStarted = true;
            }
        });
        hardcoreModeButton.addEventListener('click', () => {
            modeSelectModal.classList.add('hidden');
            if(!gameHasStarted) {
                isCustomGame = false;
                init('hardcore');
                gameHasStarted = true;
            }
        });

        indexButton.addEventListener('click', () => {
            if (gameIndexModal.classList.contains('hidden')) {
                if (!isPaused && gameHasStarted) togglePause();
                gameIndexModal.classList.remove('hidden');
                setTimeout(() => gameIndexModal.classList.remove('opacity-0', 'scale-90'), 10);
            } else {
                if (isPaused && gameHasStarted) togglePause();
                gameIndexModal.classList.add('opacity-0', 'scale-90');
                setTimeout(() => gameIndexModal.classList.add('hidden'), 300);
            }
        });
        closeIndexButton.addEventListener('click', () => {
            if(isPaused && gameHasStarted) togglePause();
            gameIndexModal.classList.add('opacity-0', 'scale-90');
            setTimeout(() => gameIndexModal.classList.add('hidden'), 300);
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden && gameHasStarted && !isPaused) {
                togglePause();
                saveGame(); // Auto-save when tab loses focus
            }
        });
        
        showTowersTab.addEventListener('click', () => {
            towerIndexContent.classList.remove('hidden');
            enemyIndexContent.classList.add('hidden');
            showTowersTab.classList.add('active');
            showEnemiesTab.classList.remove('active');
        });
        
        showEnemiesTab.addEventListener('click', () => {
            towerIndexContent.classList.add('hidden');
            enemyIndexContent.classList.remove('hidden');
            showTowersTab.classList.remove('active');
            showEnemiesTab.classList.add('active');
        });

        // Save/Load Listeners
        saveButton.addEventListener('click', saveGame);
        continueButton.addEventListener('click', loadGame);

        resetSaveButton.addEventListener('click', () => {
            if (!isPaused && gameHasStarted) togglePause();
            resetSaveModal.classList.remove('hidden', 'opacity-0', 'scale-90');
        });

        confirmResetButton.addEventListener('click', () => {
            localStorage.removeItem('gctd_save');
            resetSaveModal.classList.add('opacity-0', 'scale-90');
            setTimeout(() => resetSaveModal.classList.add('hidden'), 300);
            if (isPaused && gameHasStarted) togglePause();
            checkForSave(); // This will hide the continue button
            floatingTexts.push({
                x: canvasWidth / 2, y: canvasHeight / 2,
                content: 'Save Deleted', color: '255, 100, 100',
                duration: 120, size: 40
            });
        });
        
        cancelResetButton.addEventListener('click', () => {
            resetSaveModal.classList.add('opacity-0', 'scale-90');
            setTimeout(() => resetSaveModal.classList.add('hidden'), 300);
            if (isPaused && gameHasStarted) togglePause();
        });

        // --- Admin Panel Logic ---
        adminPanelButton.addEventListener('click', () => {
            adminPanel.classList.toggle('hidden');
        });
        closeAdminPanel.addEventListener('click', () => {
            adminPanel.classList.add('hidden');
        });
        executeSkipWaves.addEventListener('click', () => {
            const numWaves = parseInt(skipWavesInput.value, 10);
            if (!isNaN(numWaves) && numWaves > 0) {
                adminSkipWaves(numWaves);
            }
        });
         executeSetWave.addEventListener('click', () => {
            const targetWave = parseInt(setWaveInput.value, 10);
            if (!isNaN(targetWave) && targetWave >= 1) {
                adminSetWave(targetWave);
            }
        });
        executeSetSpeed.addEventListener('click', () => {
            const speed = parseFloat(setSpeedInput.value);
            if (!isNaN(speed) && speed > 0) {
                setGameSpeed(speed);
            }
        });
        executeAddGold.addEventListener('click', () => {
            const amount = parseInt(addGoldInput.value, 10);
            if (!isNaN(amount)) {
                gold += amount;
                updateUI();
            }
        });
        executeKillAll.addEventListener('click', () => {
            enemies = [];
        });
        executeSetHealth.addEventListener('click', () => {
            const health = parseInt(setHealthInput.value, 10);
            if(!isNaN(health) && health > 0) {
                baseHealth = health;
                maxBaseHealth = health;
                updateUI();
            }
        });
        invincibleBaseToggle.addEventListener('change', (e) => {
            isBaseInvincible = e.target.checked;
        });
         executeGrassColor.addEventListener('click', () => {
            const color = grassColorInput.value;
            backgroundColor = color;
            createGreenBackground(color);
        });
        musicToggle.addEventListener('change', toggleMusic);
        executeEnemyHealthMod.addEventListener('click', () => {
            const mod = parseFloat(enemyHealthModInput.value);
            if(!isNaN(mod) && mod > 0) {
                enemyStrengthModifier = mod;
            }
        });
        executeEnemySpeedMod.addEventListener('click', () => {
            const mod = parseFloat(enemySpeedModInput.value);
            if(!isNaN(mod) && mod > 0) {
                enemySpeedModifier = mod;
            }
        });
        executeDisableTowers.addEventListener('click', () => {
            towers.forEach(t => t.disabled = 300); // Disable for 5 seconds
        });
         executeSpawnEnemy.addEventListener('click', () => {
            const enemyName = spawnEnemyInput.value.trim();
            let enemyKey = null;

            for (const key in ENEMY_DESCRIPTIONS) {
                if (ENEMY_DESCRIPTIONS[key].name.toLowerCase() === enemyName.toLowerCase()) {
                    enemyKey = key;
                    break;
                }
            }

            if(enemyKey && ENEMY_DATA[enemyKey]) {
                 const data = ENEMY_DATA[enemyKey];
                 enemies.push({ x: scaledPath[0].x, y: scaledPath[0].y, pathIndex: 0, speed: data.speed, health: data.health, maxHealth: data.health, size: canvasWidth * 0.02, gold: data.gold, type: enemyKey, visual: {}, slowed: false, slowTimer: 0, isBurning: false, burnTimer: 0, burnDamage: 0, isFrozen: false, freezeTimer: 0, isShocked: false, shockTimer: 0, ability: data.ability || null, resistance: data.resistance || null, lastHitBy: null, attackingMonolith: null });
            }
        });

        adminDemonMode.addEventListener('click', () => adminSetWave(100));
        adminHellMode.addEventListener('click', () => adminSetWave(1000));
        adminMaxTowers.addEventListener('click', () => {
            towers.forEach(t => { 
                if (gold < t.upgradeCost * (10 - t.level)) {
                    gold += t.upgradeCost * (10 - t.level);
                }
                for(let i = t.level; i < 10; i++) upgradeTower(t); 
            });
        });
        adminGiveAll.addEventListener('click', () => {
            Object.keys(TOWER_DATA).forEach(type => {
                const x = Math.random() * canvasWidth;
                const y = Math.random() * canvasHeight;
                if(canPlaceTower(x, y)) {
                    towers.push({ x: x, y: y, type: type, size: canvasWidth * 0.035, range: canvasWidth * TOWER_DATA[type].range, fireRate: TOWER_DATA[type].fireRate, fireCooldown: 0, damage: TOWER_DATA[type].damage, projectileType: TOWER_DATA[type].projectile, level: 1, upgradeCost: TOWER_DATA[type].cost * 2, totalSpent: TOWER_DATA[type].cost, shield: 0, disabled: 0, currentTarget: null, damageBonus: 0 });
                }
            });
        });
        adminTriggerAbilities.addEventListener('click', () => {
            towers.forEach(t => t.fireCooldown = 0);
        });


        window.addEventListener('keydown', handleCheatCode);

        function handleCheatCode(e) {
            if (gameOver) return;
            keySequence.push(e.key);
            if (keySequence.length > 20) {
                keySequence.shift();
            }

            const adminCodeStr = adminCode.join('');
            const currentSequenceStr = keySequence.join('');

            if (currentSequenceStr.endsWith(adminCodeStr)) {
                adminPanelButton.classList.remove('hidden');
                floatingTexts.push({
                    x: canvasWidth / 2,
                    y: canvasHeight / 2,
                    content: 'Admin Panel Unlocked',
                    color: '0, 191, 255',
                    duration: 240,
                    size: 50
                });
                if (audioStarted) buildSynth.triggerAttackRelease("C5", "4n");
                keySequence = []; // Reset sequence
            }
        }

        function adminSkipWaves(numWaves) {
            if (timerInterval) clearInterval(timerInterval);
            
            enemies = [];
            projectiles = [];
            waveInProgress = false;
            bossSpawned = false;

            for (let i = 0; i < numWaves; i++) {
                gold += 100 + (wave + i + 1) * 10;
            }
            wave += numWaves;
            
            floatingTexts.push({
                x: canvasWidth / 2,
                y: canvasHeight / 2,
                content: `+${numWaves} Waves!`,
                color: '0, 255, 255',
                duration: 180,
                size: 50
            });

            if (audioStarted) buildSynth.triggerAttackRelease("G5", "4n");
            
            updateUI();
            startWaveTimer();
        }

        function adminSetWave(targetWave) {
            if (timerInterval) clearInterval(timerInterval);
            enemies = [];
            projectiles = [];
            specialEffects = [];
            waveInProgress = false;
            bossSpawned = false;
            wave = targetWave - 1;
            floatingTexts.push({
                x: canvasWidth / 2, y: canvasHeight / 2,
                content: `Set to Wave ${targetWave}`, color: '0, 191, 255',
                duration: 180, size: 50
            });

            if (audioStarted) buildSynth.triggerAttackRelease("G5", "4n");
            updateUI();
            startNextWave();
        }

        // --- Vote Logic ---
        function updateVoteDisplay() {
            const yesVotes = parseInt(localStorage.getItem('gctd_vote_yes') || '0');
            const noVotes = parseInt(localStorage.getItem('gctd_vote_no') || '0');
            const totalVotes = yesVotes + noVotes;
            voteCountYes.textContent = yesVotes;
            voteCountNo.textContent = noVotes;
            const yesPercent = totalVotes === 0 ? 50 : (yesVotes / totalVotes) * 100;
            voteBarYes.style.width = `${yesPercent}%`;
            
            if(localStorage.getItem('gctd_voted')) {
                voteYesButton.disabled = true;
                voteNoButton.disabled = true;
                voteYesButton.classList.add('opacity-50');
                voteNoButton.classList.add('opacity-50');
            }
        }

        voteButton.addEventListener('click', () => {
            if (!isPaused && gameHasStarted) togglePause();
            updateVoteDisplay();
            voteModal.classList.remove('hidden', 'opacity-0', 'scale-90');
        });

        closeVoteButton.addEventListener('click', () => {
            voteModal.classList.add('opacity-0', 'scale-90');
            setTimeout(() => voteModal.classList.add('hidden'), 300);
            if (isPaused && gameHasStarted) togglePause();
        });

        voteYesButton.addEventListener('click', () => {
            if (!localStorage.getItem('gctd_voted')) {
                const yesVotes = parseInt(localStorage.getItem('gctd_vote_yes') || '0');
                localStorage.setItem('gctd_vote_yes', yesVotes + 1);
                localStorage.setItem('gctd_voted', 'true');
                updateVoteDisplay();
            }
        });

        voteNoButton.addEventListener('click', () => {
            if (!localStorage.getItem('gctd_voted')) {
                const noVotes = parseInt(localStorage.getItem('gctd_vote_no') || '0');
                localStorage.setItem('gctd_vote_no', noVotes + 1);
                localStorage.setItem('gctd_voted', 'true');
                updateVoteDisplay();
            }
        });

        // --- Custom Game Logic ---
        function showCustomModal(modalToShow) {
            document.querySelectorAll('.custom-game-modal').forEach(m => m.classList.add('hidden'));
            if(modalToShow) modalToShow.classList.remove('hidden');
        }

        customModeButton.addEventListener('click', () => {
            modeSelectModal.classList.add('hidden');
            populateCustomTowerSelection();
            showCustomModal(customTowerSelectModal);
        });
        
        customTowersNextButton.addEventListener('click', () => {
            customEnabledTowers = [];
            document.querySelectorAll('#custom-tower-select-modal input:checked').forEach(checkbox => {
                customEnabledTowers.push(checkbox.dataset.type);
            });
            if(customEnabledTowers.length > 0) {
                populateCustomEnemySelection();
                showCustomModal(customEnemySelectModal);
            } else {
                alert("Please select at least one tower!");
            }
        });

        customEnemiesBackButton.addEventListener('click', () => showCustomModal(customTowerSelectModal));
        
        customEnemiesNextButton.addEventListener('click', () => {
             customEnabledEnemies = [];
            document.querySelectorAll('#custom-enemy-select-modal input:checked').forEach(checkbox => {
                customEnabledEnemies.push(checkbox.dataset.type);
            });
            if(customEnabledEnemies.length > 0) {
                showCustomModal(customDifficultySelectModal);
            } else {
                alert("Please select at least one enemy!");
            }
        });

        customDifficultyBackButton.addEventListener('click', () => showCustomModal(customEnemySelectModal));

        document.querySelectorAll('.difficulty-button').forEach(button => {
            button.addEventListener('click', (e) => {
                const difficultyValue = parseFloat(e.currentTarget.dataset.difficulty);
                difficultyModifier = { health: difficultyValue, speed: difficultyValue };
                currentDifficulty = e.currentTarget.textContent.toLowerCase();
                 document.querySelectorAll('.difficulty-button').forEach(b => b.classList.remove('ring-4', 'ring-blue-400'));
                 e.currentTarget.classList.add('ring-4', 'ring-blue-400');
            });
        });
        
        customStartGameButton.addEventListener('click', () => {
             if(!currentDifficulty) { alert("Please select a difficulty!"); return; }
             isCustomGame = true;
             init(currentDifficulty);
             gameHasStarted = true;
             showCustomModal(null); // Hide all custom modals
        });


        function populateCustomTowerSelection() {
            const container = document.querySelector('#custom-tower-select-modal .custom-select-content');
            container.innerHTML = '';
            Object.keys(TOWER_DATA).forEach(type => {
                // ... create checkbox, icon, label, etc. and append ...
                 container.innerHTML += `<label class="flex items-center space-x-2 p-2 bg-white/50 rounded-lg cursor-pointer hover:bg-white/80"><input type="checkbox" data-type="${type}" class="h-5 w-5 rounded"><span>${TOWER_DATA[type].name}</span></label>`;
            });
        }
        function populateCustomEnemySelection() {
            const container = document.querySelector('#custom-enemy-select-modal .custom-select-content');
            container.innerHTML = '';
            Object.keys(ENEMY_DATA).forEach(type => {
                // ... create checkbox, icon, label, etc. and append ...
                 container.innerHTML += `<label class="flex items-center space-x-2 p-2 bg-white/50 rounded-lg cursor-pointer hover:bg-white/80"><input type="checkbox" data-type="${type}" class="h-5 w-5 rounded"><span>${ENEMY_DESCRIPTIONS[type].name}</span></label>`;
            });
        }


        // --- Initialisation on page load (for non-game elements) ---
        resizeCanvas();
        setupTowerData();
        createTowerButtons();
        populateIndex();
        checkForSave();
        updateVoteDisplay();

    </script>
</body>
</html>

